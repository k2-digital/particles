<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>particles Earth</title>
		<style>
			html,body{ overflow: hidden; cursor: grab; }
			html:active, body:active { cursor: grabbing; }
			body { padding:0; margin: 0; background: rgb(70,15,44);
background: linear-gradient(115deg, rgba(70,15,44,1) 0%, rgba(112,23,71,1) 50%, rgba(164,45,72,1) 100%); }
			canvas { width: 100%; height: 100%; }
		</style>
	</head>
	<body>
		<script id="vertexShader" type="x-shader/x-vertex">
			uniform float angle;
			uniform float distance;
			varying vec3 vColor;
			const float PI = 3.1415926535897932384626433832795;
			void main()	{
				vec3 newPosition = position;
				vec4 position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);

				float x = pow(newPosition.x + (distance * sin(angle * float(PI / 180.0))), 2.0);
				float y = pow(newPosition.y + (distance * cos(angle * float(PI / 180.0))), 2.0);
				float z = pow(newPosition.z + 3., 2.0);
				float dist = x + y + z;

				gl_Position = position;
				gl_PointSize = max((dist / 10.) , 3.);

				float white = max(dist * .001, 0.);
				vColor = vec3(98./255.,20./255.,60./255.) * white;
			}
		</script>
		<script id="fragmentShader" type="x-shader/x-fragment">
			uniform sampler2D texture;
			varying vec3 vColor;
			void main()	{
				vec4 textureColor = texture2D(texture, gl_PointCoord);
				if ( textureColor.w < .8 ) discard;
				gl_FragColor = vec4(vColor.rgb, 1.) * textureColor;
			}
		</script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/105/three.min.js"></script>
        <!-- <script src="https://threejs.org/examples/js/loaders/LoaderSupport.js"></script>
		<script src="https://threejs.org/examples/js/loaders/OBJLoader2.js"></script> -->
		<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/2.1.2/TweenMax.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5/dat.gui.min.js"></script>
		<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/controls/OrbitControls.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/chroma-js/2.0.3/chroma.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/2.1.3/TweenMax.min.js"></script>
		<script>


			//
			// Random
			//
			var random = function( min , max , isRound ){
				var ran = (Math.random() * (max - min)) + min;
				if(isRound)
					return Math.round(ran);
				else
					return ran;
			}


			function calcPosFromLatLonRad(lat,lon,radius){
				var phi   = (90-lat)*(Math.PI/180)
				var theta = (lon+180)*(Math.PI/180)

				x = -((radius) * Math.sin(phi)*Math.cos(theta))
				z = ((radius) * Math.sin(phi)*Math.sin(theta))
				y = ((radius) * Math.cos(phi))

				return [x,y,z]
			}

            var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, .1, 1000 );
			var dist = 22;
			camera.position.z = dist;
			// find visible of screen width and height
			var vFOV = THREE.Math.degToRad( camera.fov );
			var height = 2 * Math.tan( vFOV / 2 ) * dist;
			var width = height * camera.aspect;
			//
			// var controls = new THREE.OrbitControls( camera );


            var renderer = new THREE.WebGLRenderer( { antialias: true, alpha:true } );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setClearColor( 0x000000, 0 );
			document.body.appendChild( renderer.domElement );


			// light
            // var ambientLight = new THREE.AmbientLight( 0x666666 );
            // scene.add( ambientLight );
            // var lights = [];
			// lights[ 0 ] = new THREE.PointLight( 0xff0000, 1, 0 );
			// lights[ 1 ] = new THREE.PointLight( 0x00ff00, 1, 0 );
			// lights[ 2 ] = new THREE.PointLight( 0x0000ff, 1, 0 );

			// lights[ 0 ].position.set( -width/2, 0, 0 );
			// lights[ 1 ].position.set( width/2, 0, 0 );
			// lights[ 2 ].position.set( 0, 0 , 22 );

			// scene.add( lights[ 0 ] );
			// scene.add( lights[ 1 ] );
			// scene.add( lights[ 2 ] );


			window.addEventListener( 'resize', onWindowResize, false );
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			// gui
			var options = {
				angle: 45,
				distance: 16
			}
			var gui = new dat.GUI({width: 300});
			gui.add(options,'angle').min(0).max(360).name('Angle');
			gui.add(options,'distance').min(1).max(30).name('Distance');

			var createTexture = function(text,size){
				var actualSize = 1024;
				var canvas = document.createElement('canvas');
				var ctx = canvas.getContext('2d');
				ctx.canvas.width = actualSize;
				ctx.canvas.height = actualSize;
				ctx.beginPath();
				ctx.arc(actualSize/2, actualSize/2, actualSize/2, 0, 2 * Math.PI);
				ctx.fillStyle = 'white';
				ctx.fill();
				if(text){
					ctx.fillStyle = 'red';
					ctx.fill();
					ctx.font = (actualSize/(size*2))+"px Arial";
					ctx.fillStyle = 'white';
					ctx.fontWeight = "bold";
					ctx.textAlign = "center";
					ctx.fillText(text, actualSize/2 , actualSize/2 + ((actualSize/(size*2))/3) );
				}
				return canvas;
			}

			var uniforms = {
				angle:{ value: options.angle },
				distance:{ value: options.distance },
				texture:{
					type:'t',
					value: new THREE.CanvasTexture(createTexture())//new THREE.TextureLoader().load('https://image.flaticon.com/icons/svg/60/60765.svg')
				}
			};
			

			var geometry = new THREE.IcosahedronGeometry(.3,3);
			var m = new THREE.MeshBasicMaterial({color: 0xffff00});
			var _mesh = new THREE.Mesh( geometry, m );
			_mesh.position.x = 5;
			_mesh.position.y = 5;
			_mesh.position.z = 0;
			scene.add(_mesh);



			// particles
			var locations = new THREE.Group();
			var particles;
			var particlesGeometry = new THREE.IcosahedronGeometry(10,3);
			var init = function(){
				var particlesMaterial = new THREE.ShaderMaterial({
					uniforms: uniforms,
					vertexShader: document.getElementById('vertexShader').textContent,
					fragmentShader: document.getElementById('fragmentShader').textContent,
					// blending: THREE.AdditiveBlending,
					// depthTest: true,
					// depthWrite: true,
    				// transparent: true,
				});
				particles = new THREE.Points( particlesGeometry, particlesMaterial );
				scene.add( particles );
			}
			init();
			//
			var latlog = [
				[22.3531282,113.8475118,'HK',2],
				[36.2497092,-113.7004455,'USA',5],
				[54.2315724,-13.4279228,'UK',3]
			];
			for(var i=0; latlog[i]; i++){
				var p = calcPosFromLatLonRad(latlog[i][0],latlog[i][1],10);
				var pointGeometry = new THREE.BufferGeometry();
				var positions = new Float32Array( 3 );
				var pointsMaterial = new THREE.PointsMaterial({
					color:0xffffff,
					size:latlog[i][3],
					map:new THREE.CanvasTexture(createTexture(latlog[i][2],latlog[i][3])),
					depthTest: false,
					// depthWrite: false,
					// blending: THREE.AdditiveBlending,
    				transparent: true,
				});
				pointGeometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
				for(var j=0; j<3; j+=3){
					var array = pointGeometry.attributes.position.array;
					array[j] = p[0]*1.01;
					array[j+1] = p[1]*1.01;
					array[j+2] = p[2]*1.01;
				}
				var point = new THREE.Points( pointGeometry, pointsMaterial );
				locations.add(point);
			}
			scene.add(locations);


			// var raycaster = new THREE.Raycaster();
			// var _mouse = new THREE.Vector2(), INTERSECTED;
			// var radius = 8;
			
			var start = Date.now();
            var animate = function () {
				requestAnimationFrame( animate );
				var deltaRotationQuaternion = new THREE.Quaternion()
				.setFromEuler(new THREE.Euler(
					toRadians(newdeltaMove.y * .3),
					toRadians(newdeltaMove.x * .3),
					0,
					'XYZ'
				));
				
				locations.quaternion.multiplyQuaternions(deltaRotationQuaternion, locations.quaternion);

				particles.quaternion.multiplyQuaternions(deltaRotationQuaternion, particles.quaternion);
				particles.updateMatrix(); 
				particles.geometry.applyMatrix( particles.matrix );
				particles.matrix.identity();
				particles.rotation.set(0,0,0);
				particles.updateMatrix(); 

				// locations.updateMatrix(); 
				// locations.matrix.identity();


				// raycaster.setFromCamera( _mouse, camera );

				// Conver 2d position to 3d position
				// var vector = new THREE.Vector3(_mouse.x, _mouse.y, 0.5);
				// vector.unproject( camera );
				// var dir = vector.sub( camera.position ).normalize();
				// var distance = - camera.position.z / dir.z;
				// mouse = camera.position.clone().add( dir.multiplyScalar( distance ) );


				// for(var i=0; i<particles.children.length; i++){
				// 	var mesh = particles.children[i];
				// 	if(mouse){
				// 		// get distance from mouse to mesh
				// 		dist = Math.sqrt(Math.pow((mouse.x - mesh.original.x), 2) + Math.pow((mouse.y - mesh.original.y), 2));
				// 	}
				// }

				var timer = (Date.now() - start) * .05;

				_mesh.position.x = options.distance * Math.sin(options.angle * (Math.PI / 180));
				_mesh.position.y = options.distance * Math.cos(options.angle * (Math.PI / 180));



				particles.material.uniforms.angle.value = options.angle;
				particles.material.uniforms.distance.value = options.distance;

				camera.lookAt(new THREE.Vector3(0,0,0));
				// console.log(camera.position);
                // controls.update();
				renderer.render( scene, camera );
            };

			var clicked = false;
			var currentPos = {x:0,y:0};
			var prevPos = {x:0,y:0};
			var mouse = {x:0,y:0};
			var deltaMove = {x:0,y:0};
			var newdeltaMove = {x:-0.1,y:0.1};
			window.addEventListener('mousemove',function(event){
				// Update the mouse variable
				// <-   width  ->
				// -1     0     1
				if(clicked){
					deltaMove = {
						x:event.clientX - prevPos.x,
						y:event.clientY - prevPos.y
					}

					newdeltaMove.x += ( deltaMove.x - newdeltaMove.x) * .1;
					newdeltaMove.y += ( deltaMove.y - newdeltaMove.y) * .1;
					
					prevPos = {
						x:event.clientX,
						y:event.clientY
					}

					// _mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
					// _mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
				}
			}, false);

			window.addEventListener('mousedown',function(event){
				clicked = true;
				prevPos = {
					x:event.clientX,
					y:event.clientY
				}
				
			})
			window.addEventListener('mouseup',function(event){
				clicked = false;
			});

			var toRadians = function(angle){
				return angle * (Math.PI / 180);
			}

            animate();
		</script>
	</body>
</html>