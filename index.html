<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>particles</title>
		<style>
			body { padding:0; margin: 0; position: relative; background:#000; }
			.dg.ac{ z-index:999 !important; }

			#bg{ width:100%; height:100%; position: fixed; top:0; left:0; z-index: 0; }
			.color{
				width:100%;
				height:100%;
				position: absolute;
				top:0;
				left:0;
				opacity: 0;
				visibility: hidden;
				transition: all .6s ease-out;
				z-index: 1;
			}
			.color.active{
				opacity: 1;
				visibility: visible;
				transition-delay: 0ms;
				z-index: 2;
			}
			#color1{
				/* background:linear-gradient(333deg, rgba(165,45,72,1) 0%, rgba(125,26,78,1) 40%, rgba(63,12,39,1) 100%);  */
				background:#8b2451;
			}
			#color2{
				background:linear-gradient(225deg, rgb(34, 34, 34) 0%, rgb(39, 39, 39) 30%, rgb(51, 51, 51) 100%); 
			}
			#color3{
				background:linear-gradient(225deg, rgba(2,72,66,1) 0%, rgba(0,81,76,1) 30%, rgba(0,108,110,1) 100%); 
			}
			#color4{
				background:linear-gradient(331deg, rgba(8,1,99,1) 0%, rgba(15,12,64,1) 70%, rgba(3,4,38,1) 100%);
			}

			#sectionWrap{ width:100%; position: relative; z-index:2; }
			#sectionWrap .section{ width:100%; height:100vh; color:#fff; }
			#sectionWrap .section > span{ position: absolute; }
			#sectionWrap .section #balls{ width:100%; height:100%; position: relative; }
			#sectionWrap .section #balls .ballDiv{ width:19vh; position: absolute; cursor: pointer; opacity:0; visibility: hidden; }
			#sectionWrap .section #balls .ballDiv:after{ content:''; display:block; padding-top:100%; }
			#sectionWrap .section #balls .ballDiv span{ font-size:20px; color:#fff; text-align: center; position: absolute; top:50%; left:50%; transform: translate3d(-50%,-50%,0); }
			canvas{ position: fixed; top:0; left:0; display: block; z-index:1; }
		</style>
	</head>
	<body>
		<div id="sectionWrap">
			<div class="section">
				<span>1</span>
			</div>
			<div class="section"><span>2</span></div>
			<div class="section"><span>3</span>
				<div id="balls">
					<div class="ballDiv"><span>Real<br/>Estate</span></div>
					<div class="ballDiv"></div>
					<div class="ballDiv"></div>
					<div class="ballDiv"></div>
					<div class="ballDiv"></div>
					<div class="ballDiv"></div>
					<div class="ballDiv"></div>
					<div class="ballDiv"></div>
				</div>
			</div>
		</div>
		<div id="bg">
			<div id="color1" class="color active"></div>
			<div id="color2" class="color"></div>
			<div id="color3" class="color"></div>
			<div id="color4" class="color"></div>
		</div>
		<script id="vertexShader" type="x-shader/x-vertex">
			//attribute vec3 color;
			//attribute float isBg;

			//varying vec4 vColor;
			uniform float time;
			uniform float size;
			void main()	{
				vec3 newPosition = position;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
				if(time > 0.){
					newPosition.x += (sin(newPosition.x + time * .2) * cos(newPosition.y + time * .2)) * .2;
					newPosition.y += (cos(newPosition.y + time * .2) * sin(newPosition.z + time * .2)) * .2;
					//newPosition.z += -cos(newPosition.z + time) * .04;
				}

				vec4 position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
				gl_Position = position;

				//vColor = vec4(color,1.);

				float x = pow(newPosition.x, 2.0);
				float y = pow(newPosition.y, 2.0);
				float z = pow(newPosition.z + 15., 2.0);
				float dist = x + y + z;

				gl_PointSize = size + (dist / 100.);
			}
		</script>
	
		<script id="fragmentShader" type="x-shader/x-fragment">
			//varying vec4 vColor;
			uniform sampler2D texture;
			uniform vec3 fogColor;
			uniform float fogNear;
			uniform float fogFar;
			void main()	{
				vec4 textureColor = texture2D(texture, gl_PointCoord);
				if ( textureColor.w < .8 ) discard;
				gl_FragColor = vec4(255./255., 209./255., 150./255., .05) * textureColor;
				#ifdef USE_LOGDEPTHBUF_EXT
					float depth = gl_FragDepthEXT / gl_FragCoord.w;
				#else
					float depth = gl_FragCoord.z / gl_FragCoord.w;
				#endif
				float fogFactor = smoothstep( fogNear, fogFar, depth );
		  
				//gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
				//gl_FragColor.rgb = gl_FragColor.rgb;
			}
		</script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/105/three.min.js"></script>
        <script src="./LoaderSupport.js"></script>
		<script src="./OBJLoader2.js"></script>
		<!-- <script src="http://dev.miaumiau.cat/curl_particles_collision/js/CameraControl.js"></script> -->
		<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/2.1.2/TweenMax.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5/dat.gui.min.js"></script>
		<script src="./OrbitControls.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/chroma-js/2.0.3/chroma.min.js"></script>
		<script>

			//
			// Random
			//
			var random = function( min , max , isRound ){
				var ran = (Math.random() * (max - min)) + min;
				if(isRound)
					return Math.round(ran);
				else
					return ran;
			}

			//
			// Add, Remove and Has Class
			//
			var hasClass = function(el, className){
				if(el.classList)
					return el.classList.contains(className)
				else
					return !!el.className.match(new RegExp('(\\s|^)' + className + '(\\s|$)'))
			}

			var  addClass = function(el, className){
				if(el.classList)
					el.classList.add(className)
				else if(!hasClass(el, className)) el.className += " " + className
			}

			var removeClass = function(el, className){
				var isNodelist = (typeof el.length != 'undefined' && typeof el.item != 'undefined')
				if(isNodelist){
					var els = el;

					for(var i=0; els[i]; i++){
						if(els[i].classList)
							els[i].classList.remove(className)
						else if(hasClass(els[i], className)){
							var reg = new RegExp('(\\s|^)' + className + '(\\s|$)')
							els[i].className=els[i].className.replace(reg, ' ')
						}
					}
				}
				else{
					if(el.classList)
						el.classList.remove(className)
					else if(hasClass(el, className)){
						var reg = new RegExp('(\\s|^)' + className + '(\\s|$)')
						el.className=el.className.replace(reg, ' ')
					}
				}
			}


			var maxPoints = 32000;
			var bgPoints = 1000;
			var started = false;
			var options = {};
			var scene, camera, renderer;
			var finallyPoint, bgPoint, modelPoint = [];
			var pointsGeometry, bgPointsGeometry, cubePointsGeometry;
			var pointsMaterial, uniforms;
			var targetMesh, target = [];
			var objFiles = [
				['./model1.obj', -5],
				['./model2.obj', -6.5],
				['./model3.obj', -12.5]
			];
			var latlog = [
				//lat, log, name, fontSize, circleSize
				[32.694775,129.425179,'Japan',-50,200],
				[34.4541416,86.0706458,'China',-50,200],
				[36.2497092,-113.7004455,'U.S.',-300,400],
				[54.2315724,-13.4279228,'U.K.',50,150],
				[-24.9910822,115.2154973,'Australia',100, 100]
			];
			var section = 0;
			var oldSection = 0;
			var ballDegree = 360/8;

			var init = function(){
				scene = new THREE.Scene();
				scene.fog = new THREE.Fog( 0x000000, 53, 63 );
				scene.fog.color = new THREE.Color(0x3f0c27);
				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 1000 );
				camera.position.z = 55;
				var dist = camera.position.z;
				var vFOV = THREE.Math.degToRad( camera.fov );
				screenHeight = 2 * Math.tan( vFOV / 2 ) * dist;
				screenwidth = screenHeight * camera.aspect;
				var controls = new THREE.OrbitControls( camera );

				renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setClearColor( 0x000000, 0 );
				document.body.appendChild( renderer.domElement );


				options = {
					wave: false,
					lightHelper: false,
					point:{
						size:0,
						depth:.8
					},
					camera:{
						z:camera.position.z
					},
					fogNear:scene.fog.near,
					fogFar:scene.fog.far,
					ToModel1: function(){
						// morphTo(ballsPoint);
						TweenMax.to('html,body',1,{scrollTop:0, ease:Power4.easeOut});
						TweenMax.to(locationPoint.material.uniforms.size, .6, {value: 0, overwrite:'all', ease:Power4.easeOut});
					},
					ToModel2: function(){
						morphTo(earthPoint);
						TweenMax.to('html,body',1,{scrollTop:1 * window.innerHeight, ease:Power4.easeOut});
						TweenMax.to(locationPoint.material.uniforms.size, 1.3, {value: 1, ease:Elastic.easeOut.config(1, 0.3)});
					},
					ToModel3: function(){
						morphTo(cubePoints);
						setTimeout(function(){morphTo(ballsPoint);},1000);
						TweenMax.to('html,body',1,{scrollTop:2 * window.innerHeight, ease:Power4.easeOut});
						TweenMax.to(locationPoint.material.uniforms.size, .6, {value: 0, overwrite:'all', ease:Power4.easeOut});
					}
				}

				window.addEventListener( 'resize', onWindowResize, false );
				function onWindowResize() {
					updateBallDiv();

					camera.aspect = window.innerWidth / window.innerHeight;
					camera.updateProjectionMatrix();
					renderer.setSize( window.innerWidth, window.innerHeight );
				}

				
				initGUI();
				initLoadOBJ();
				initParticle();
				initBg();
				initSection1();
				initSection2();
				initSection3();
				renderer.setAnimationLoop(function(){
					update();
					render();
				})
			}

			var initGUI = function(){
				var gui = new dat.GUI({width: 300});
					gui.add(options.point, 'size').min(0).max(5).name('Size of particle');
					gui.add(options.camera, 'z').min(0).max(100).name('Move Camera');
					var _f = gui.addFolder('Fog');
					_f.add(options, 'fogNear').min(.1).max(100).name('Near');
					_f.add(options, 'fogFar').min(20).max(100).name('Far');
					_f.open();
					gui.add(options, 'ToModel1').name('Section 1');
					gui.add(options, 'ToModel2').name('Section 2');
					gui.add(options, 'ToModel3').name('Section 3');
					gui.add(options, 'wave').name('Let\'s Wave!');
					gui.add(options, 'lightHelper').name('Enable light helper');
			}

			var createTexture = function(color, text, fontSize, circleSize){
				var fixedSize = 1024;
				var actualSize = circleSize;
				var canvas = document.createElement('canvas');
				var ctx = canvas.getContext('2d');
				ctx.canvas.width = fixedSize;
				ctx.canvas.height = fixedSize;
				ctx.beginPath();
				ctx.arc(fixedSize/2, fixedSize/2, fixedSize/2, 0, 2 * Math.PI);
				ctx.fillStyle = color;
				ctx.fill();
				if(text){
					ctx.font = (actualSize + fontSize)+"px Arial";
					ctx.fillStyle = 'white';
					ctx.textAlign = "center";
					ctx.fillText(text, fixedSize/2 , fixedSize/2 + (actualSize + fontSize)/3 );
				}
				return canvas;
			}

			var initParticle = function(){
				pointsGeometry = new THREE.BufferGeometry();
				bgPointsGeometry = new THREE.BufferGeometry();
				cubePointsGeometry = new THREE.BufferGeometry();
				
				uniforms = {
					time: { value: 0 },
					size: { value: options.point.size },
					texture:{
						type: "t",
						value: new THREE.CanvasTexture(createTexture('white'))//new THREE.TextureLoader().load('https://klevron.github.io/codepen/misc/star.png')
					},
					fogColor:    { type: "c", value: scene.fog.color },
					fogNear:     { type: "f", value: scene.fog.near },
					fogFar:      { type: "f", value: scene.fog.far }
				};
				

				pointsMaterial = new THREE.ShaderMaterial({
					uniforms: uniforms,
					vertexShader: document.getElementById('vertexShader').textContent,
					fragmentShader: document.getElementById('fragmentShader').textContent,
					blending: THREE.AdditiveBlending,
					// depthTest: true,
					depthWrite: false,
					// transparent: true,
					fog:true
				});


				// cube point position
				var positions = new Float32Array( maxPoints * 3 );
				for(var i=0; i<maxPoints; i++){
					var pos = new THREE.Vector3(
						THREE.Math.randFloat(-20,20),
						THREE.Math.randFloat(-20,20),
						50
					);
					pos.toArray(positions,i*3);
				}
				cubePointsGeometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
				cubePoints = new THREE.Points( cubePointsGeometry, new THREE.MeshBasicMaterial() );
			}

			var initBg = function(){
				var positions = new Float32Array( bgPoints * 3 );
				tempBgPos = new Float32Array( bgPoints * 3 );
				var colors = new Float32Array( bgPoints * 3 );
				// var isBg = new Float32Array( bgPoints );
				for(var i=0; i<bgPoints; i++){
					var pos = new THREE.Vector3(
						THREE.Math.randFloat(-10,10),
						THREE.Math.randFloat(-10,10),
						THREE.Math.randFloat(-10,10)
					);
					pos.toArray(positions,i*3);
					pos.toArray(tempBgPos,i*3);

					color = new THREE.Color(0xffffff);
					color.toArray(colors, i*3);

					// isBg[i] = true;
				}
				bgPointsGeometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
				bgPointsGeometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ));
				// bgPointsGeometry.addAttribute( 'isBg', new THREE.BufferAttribute( isBg, 1 ));
				bgPoint = new THREE.Points( bgPointsGeometry, new THREE.PointsMaterial({ 
					size:.1, 
					color:0xffffff, 
					map:new THREE.CanvasTexture(createTexture('white')),
					transparent: true,
				}));
				scene.add(bgPoint);
			}



			var initSection1 = function(){
				var radius = 14;
				ballsGroup = new THREE.Group();
				var sphere = new THREE.IcosahedronGeometry(4.3,4);
				for(var i=0; i<8; i++){
					var ball = sphere.clone();
					var ballMesh = new THREE.Mesh( ball, new THREE.MeshPhongMaterial({ 
						color: 0x8b2451,
						shininess:0,
						specular: 0xffffff
					}));
					ballMesh.position.x = radius * Math.sin((ballDegree*i) * (Math.PI/180));
					ballMesh.position.y = radius * Math.cos((ballDegree*i) * (Math.PI/180));
					ballMesh.layers.set(i+1);
					ballsGroup.add(ballMesh);
				}
				scene.add(ballsGroup);

				// lights
				lightsGroup = new THREE.Group();
				lightsHelperGroup = new THREE.Group();
				var lightParms = [
					{
						position: new THREE.Vector3(-10,2,-7),
						intensity: 7,
						distance: 18,
						angle: .5
					},
					{
						position: new THREE.Vector3(0,0,5),
						intensity: 3,
						distance: 18,
						angle: .5
					},
					{
						position: new THREE.Vector3(0,0,-10),
						intensity: 10,
						distance: 18,
						angle: .45
					},
					{
						position: new THREE.Vector3(-5,5,-5),
						intensity: 4,
						distance: 30,
						angle: .6
					},
					{
						position: new THREE.Vector3(0,0,15),
						intensity: 5,
						distance: 22,
						angle: .35
					},
					{
						position: new THREE.Vector3(0,0,4),
						intensity: 3,
						distance: 18,
						angle: .6
					},
					{
						position: new THREE.Vector3(0,-7,3),
						intensity: 3,
						distance: 18,
						angle: .6
					},
					{
						position: new THREE.Vector3(0,0,15),
						intensity: 4,
						distance: 22,
						angle: .6
					}
				]
				for(var i=0; i<8; i++){
					if(lightParms[i]){
						var spotLight = new THREE.SpotLight( 0x669E23, lightParms[i].intensity, lightParms[i].distance, lightParms[i].angle, 1 );
						spotLight.position.copy(lightParms[i].position);
						spotLight.target = ballsGroup.children[i];
						spotLight.layers.set(i+1);
						lightsGroup.add(spotLight);

						var spotLightHelper = new THREE.SpotLightHelper( spotLight );
						// spotLightHelper.layers.set(i+1);
						lightsHelperGroup.add( spotLightHelper );

						var ambientLight = new THREE.AmbientLight( 0xffffff );
						ambientLight.layers.set(i+1);
						scene.add( ambientLight );
					}
				}
				lightsHelperGroup.visible = false;
				scene.add(lightsGroup);
				scene.add(lightsHelperGroup);
			}



			var initSection2 = function(){
				// earth
				// var geometry = new THREE.IcosahedronGeometry(15,4);
				var geometry = new THREE.SphereGeometry(15,62,62);
				earthPoint = new THREE.Points( geometry , pointsMaterial );

				initLocation();
			}


			var initLocation = function(){
				var locationPointGeometry = new THREE.BufferGeometry();
				var locationPositions = new Float32Array( latlog.length * 3 );
				var locationSize = new Float32Array( latlog.length );
				var textureIdx = new Float32Array(latlog.length);
				var textures = [];			

				for(var i=0; latlog[i]; i++){
					var p = calcPosFromLatLonRad(latlog[i][0],latlog[i][1],15);
					for(var j=0; j<3; j+=3){
						var array = new THREE.Vector3(p[0], p[1], p[2]);
						array.toArray(locationPositions, i*3);
					}
					textures[i] = new THREE.CanvasTexture(createTexture('#8b2451',latlog[i][2],latlog[i][3],latlog[i][4]));
					textures[i].flipY = false;
					locationSize[i] = latlog[i][4];
					textureIdx[i] = i;
				}

				locationPointGeometry.addAttribute( 'position', new THREE.BufferAttribute( locationPositions, 3 ) );
				locationPointGeometry.addAttribute( 'locationSize', new THREE.BufferAttribute( locationSize, 1 ) );
				locationPointGeometry.addAttribute( 'textureIdx', new THREE.BufferAttribute( textureIdx, 1 ) );


				var locationPointsMaterial = new THREE.ShaderMaterial({
					uniforms: {
						size: { type:'f', value: .0 },
						textures:{
							type:'tv',
							value: textures,
						}
					},
					vertexShader: [
						'attribute float locationSize;',
						'attribute float textureIdx;',
						
						'varying float vTextureIdx;',

						'uniform float size;',

						'void main(){',
							'vTextureIdx = textureIdx;',
							'vec4 position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);',
							'gl_Position = position;',
							'gl_PointSize = locationSize * size;',
						'}'
					].join('\n'),
					fragmentShader: [
						'varying float vTextureIdx;',

						'uniform sampler2D textures['+textures.length+'];',

						'void main(){',
							'vec4 textureColor;',
							'if(vTextureIdx < .5){',
								'textureColor = texture2D(textures[0], gl_PointCoord);',
							'}else if(vTextureIdx < 1.5){',
								'textureColor = texture2D(textures[1], gl_PointCoord);',
							'}else if(vTextureIdx < 2.5){',
								'textureColor = texture2D(textures[2], gl_PointCoord);',
							'}else if(vTextureIdx < 3.5){',
								'textureColor = texture2D(textures[3], gl_PointCoord);',
							'}else if(vTextureIdx < 4.5){',
								'textureColor = texture2D(textures[4], gl_PointCoord);',
							'}',

							'if ( textureColor.w < .8 ) discard;',
							'gl_FragColor = vec4(1., 1., 1., 1.) * textureColor;',
						'}'
					].join('\n'),
					// blending: THREE.AdditiveBlending,
					// depthTest: false,
					// depthWrite: true,
					transparent: true,
					// fog:true
				});
				locationPoint = new THREE.Points( locationPointGeometry, locationPointsMaterial );
				// locationPoint.scale.set(2,2,2);
				scene.add(locationPoint);
			}


			var initSection3 = function(){
				var radius = 14;
				var combined = new THREE.Geometry();
				var sphere = new THREE.IcosahedronGeometry(4.3,4);
				for(var i=0; i<8; i++){
					var ball = sphere.clone();
					var ballMesh = new THREE.Points( ball, new THREE.MeshBasicMaterial() );
					ballMesh.position.x = radius * Math.sin((ballDegree*i) * (Math.PI/180));
					ballMesh.position.y = radius * Math.cos((ballDegree*i) * (Math.PI/180));
					ballMesh.rotation.z = THREE.Math.randFloat(-1,1);
					ballMesh.updateMatrix();
					combined.merge( ballMesh.geometry , ballMesh.matrix );
				}
				ballsPoint = new THREE.Points( combined, new THREE.PointsMaterial({ 
					size:.15,
					color: 0xffffff, 
					transparent:true
				}));
				// scene.add(ballsPoint);

				// init div
				initBallDiv();
			}

			var initBallDiv = function(){
				ballDiv = document.querySelectorAll('.ballDiv');
				// initBallDivEvent();
				updateBallDiv();
			}
			var initBallDivEvent = function(){
				for(var i=0; i<ballDiv.length; i++){
					(function(idx){
						var idx = idx;
						ballDiv[idx].addEventListener('mouseenter',function(){
							if(idx == 0){
								morphTo(ballsPoint);
							}
							else if(idx == 1){
								morphTo(modelPoint[1]);
							}
							TweenMax.to(ballsPoint.material, 1, {opacity: 0.1, overwrite:'all', ease:Power4.easeOut});
						},false);
						ballDiv[idx].addEventListener('mouseleave',function(){
							TweenMax.to(ballsPoint.material, 1, {opacity: 1, ease:Power4.easeOut, onComplete(){
								morphTo(cubePoints);
							}});
						},false);
					})(i);
				}
			}
			var updateBallDiv = function(){
				radius = window.innerHeight * .31;
				for(var i=0; i<ballDiv.length; i++){
					var w = ballDiv[i].offsetWidth;
					ballDiv[i].style.left = (radius * Math.sin((-ballDegree*i - 180) * (Math.PI/180)) + (window.innerWidth/2)-(w/2)) / 16 + 'rem';
					ballDiv[i].style.top = (radius * Math.cos((ballDegree*i - 180) * (Math.PI/180)) + (window.innerHeight/2)-(w/2)) / 16 + 'rem';
				}
			}


            var initLoadOBJ = function(){
				var manager = new THREE.LoadingManager();

				// all objects are loaded
				manager.onLoad = function(){
					console.log( 'Loading complete!');

					// init
					var cscale = chroma.scale([0x00b9e0, 0xff880a, 0x5f1b90, 0x7ec08d]);
					var positions = new Float32Array( maxPoints * 3 );
					var colors = new Float32Array( maxPoints * 3 );
					for(var i=0; i<maxPoints; i++){
						color = new THREE.Color(0xffffff);
						color.toArray(colors, i*3);

						if(earthPoint.geometry.vertices[i]){
							var pos = new THREE.Vector3(
								earthPoint.geometry.vertices[i].x,
								earthPoint.geometry.vertices[i].y,
								earthPoint.geometry.vertices[i].z
							);
						}
						else{
							var idx = THREE.Math.randInt(0,Math.round(earthPoint.geometry.vertices.length-1));
							var pos = new THREE.Vector3(
								earthPoint.geometry.vertices[idx].x,
								earthPoint.geometry.vertices[idx].y,
								earthPoint.geometry.vertices[idx].z
							);
						}
						pos.toArray(positions, i*3);
					}
					pointsGeometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
					pointsGeometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ));

					finallyPoint = new THREE.Points( pointsGeometry, pointsMaterial );
					finallyPoint.position.y = Math.min(0,screenHeight * ((window.pageYOffset - window.innerHeight)/window.innerHeight));
					finallyPoint.position.z = -10;
					scene.add(finallyPoint);

					// morphTo(modelPoint[0],'#color1',{color:0x3f0c27});
				};

				// load .obj file
				var loadObj = function(idx, file, reposition){
					var loader = new THREE.OBJLoader2(manager);
					loader.load(file, function(obj){
						var geometry = obj.detail.loaderRootNode;
						geometry.traverse(function(child){
							if ( child instanceof THREE.Mesh ){
								// change to geometry
								var geo = new THREE.Geometry().fromBufferGeometry( child.geometry );
								geo.mergeVertices();
								modelPoint[idx] = new THREE.Points( geo , pointsMaterial );
								modelPoint[idx].scale.set(2,2,2);
								modelPoint[idx].updateMatrix();
								modelPoint[idx].geometry.applyMatrix( modelPoint[idx].matrix );
								for(var i=0; modelPoint[idx].geometry.vertices[i]; i++){
									modelPoint[idx].geometry.vertices[i].y += reposition;
								}
								console.log('model'+(idx+1)+': ',modelPoint[idx].geometry.vertices.length, modelPoint[idx]);
							}
						});
					}, null, null, null, false );
				}

				// loop all files
				for(var i=0; objFiles[i]; i++){
					loadObj(i, objFiles[i][0], objFiles[i][1]);
				}
            }

			
			var morphTo = function(mesh){
				var pos = pointsGeometry.attributes.position.array;
				var isGeometry;
				var posArray;
				mesh.traverse(function(child){
					if ( child.geometry instanceof THREE.Geometry ){
						isGeometry = true;
					}
					else{
						isGeometry = false;
						posArray = child.geometry.attributes.position.array;
					}
				});
				targetMesh = mesh;
				for(var i=0; i<maxPoints; i++){
					if(isGeometry){
						if(i < targetMesh.geometry.vertices.length){
							target[i] = {
								x: targetMesh.geometry.vertices[i].x,
								y: targetMesh.geometry.vertices[i].y,
								z: targetMesh.geometry.vertices[i].z
							};
						}
						else{
							var idx = THREE.Math.randInt(0,targetMesh.geometry.vertices.length-1);
							target[i] = {
								x: targetMesh.geometry.vertices[idx].x,
								y: targetMesh.geometry.vertices[idx].y,
								z: targetMesh.geometry.vertices[idx].z
							};
						}
					}
					else{
						if(i < Math.round(posArray.length/3)){
							target[i] = {
								x: posArray[i*3+0],
								y: posArray[i*3+1],
								z: posArray[i*3+2]
							};
						}
						else{
							var idx = THREE.Math.randInt(0,Math.round(posArray.length/3));
							target[i] = {
								x: targetMesh.geometry.vertices[idx].x,
								y: targetMesh.geometry.vertices[idx].y,
								z: targetMesh.geometry.vertices[idx].z
							};
						}
					}
				}

				// update bg color
				// removeClass(document.querySelector('.color.active'),'active');
				// addClass(document.querySelector(bgColor), 'active');

				// update fog color
				// scene.fog.color = new THREE.Color(fogColor);
				// options.fogNear = fog.near != undefined ? fog.near : 25;
				// options.fogFar = fog.far != undefined ? fog.far : 50;
			}



			var start = Date.now();
            var update = function () {
				var timer = (Date.now() - start) / 10000;

				if(window.pageYOffset >= (section * window.innerHeight)){
					// if(section != oldSection){
						section++;
						// oldSection = section;
					// }
				}
				else if(window.pageYOffset < ((section-1) * window.innerHeight)){
					// if(section != oldSection){
						section--;
						// oldSection = section;
					// }
				}
				// console.log(section, window.pageYOffset, section * window.innerHeight);

				if(targetMesh){
					var pos = pointsGeometry.attributes.position.array;
					for(var i=0; i<maxPoints; i++){
						pos[i*3+0] += (target[i].x - pos[i*3+0]) * .04;
						pos[i*3+1] += (target[i].y - pos[i*3+1]) * .04;
						pos[i*3+2] += (target[i].z - pos[i*3+2]) * .04;

						// if(section == 3){
							// pos[i*3+0] += (Math.sin(target[i].x * timer) * .2) * Math.cos(target[i].y);
							// pos[i*3+1] += (Math.cos(target[i].y * timer) * .2) * (Math.sin(target[i].x));
							// pos[i*3+2] += Math.cos(target[i].z + timer);
						// } 
					}
				}

				// 
				if(finallyPoint){
					if(options.wave)
						finallyPoint.material.uniforms.time.value+=.05;
					else
						finallyPoint.material.uniforms.time.value = 0;

					var move = screenHeight * ((window.pageYOffset - window.innerHeight)/window.innerHeight);

					finallyPoint.position.y += (Math.min(0,move) - finallyPoint.position.y) * .1;
					finallyPoint.position.z += (Math.max(0,-move * 1.5) - finallyPoint.position.z) * .1;
					locationPoint.position.y += (Math.min(0,move) - locationPoint.position.y) * .1;
					locationPoint.position.z += (Math.max(0,-move * 1.5) - locationPoint.position.z) * .1;

					finallyPoint.geometry.attributes.position.needsUpdate = true;

					finallyPoint.material.uniforms.size.value = Math.max(3.6,-move) + (options.point.size * Math.max(0,-move));
				}


				//
				if(bgPoint){
					bgPoint.rotation.y = -timer/2;
					var bgpos = bgPointsGeometry.attributes.position.array;
					for(var i=0; i<bgPoints; i++){
						bgpos[i*3+0] = 40 * Math.sin(tempBgPos[i*3+0] + timer*.4);
						bgpos[i*3+1] = 40 * Math.cos(tempBgPos[i*3+1] + timer*.1);
						bgpos[i*3+2] = 40 * Math.cos(tempBgPos[i*3+2] + timer*.2);
					}
					bgPointsGeometry.attributes.position.needsUpdate = true;
					// bgPointsGeometry.attributes.isBg.needsUpdate = true;
				}

				// lights helper
				for(var i=0; i<lightsHelperGroup.children.length; i++){
					lightsHelperGroup.children[i].update();
				}

				lightsHelperGroup.visible = options.lightHelper;
			};
			
			var render = function(){
				scene.fog.near = options.fogNear;
				scene.fog.far = options.fogFar;
				camera.position.z = options.camera.z;

				renderer.autoClear = true;
				camera.lookAt(new THREE.Vector3(0,0,0));
				camera.layers.set(0);
				renderer.render( scene, camera );

				for(var i=0; i<ballsGroup.children.length; i++){
					renderer.autoClear = false;

					camera.layers.set(i+1); // << == switch camera between layers
					renderer.render(scene, camera);
				}
			}
			
			init();



			function calcPosFromLatLonRad(lat,lon,radius){
				var phi   = (90-lat)*(Math.PI/180)
				var theta = (lon+180)*(Math.PI/180)

				x = -((radius) * Math.sin(phi)*Math.cos(theta))
				z = ((radius) * Math.sin(phi)*Math.sin(theta))
				y = ((radius) * Math.cos(phi))

				return [x,y,z]
			}

		</script>
	</body>
</html>