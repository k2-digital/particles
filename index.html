<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>Landing</title>
		<style>
			body { padding:0; margin: 0; position: relative; background:#000; }
			.dg.ac{ z-index:999 !important; }

			#bgColor{ width:100%; height:100%; position: fixed; top:0; left:0; z-index: 0; background:#8b2451; }
			/*.color{
				width:100%;
				height:100%;
				position: absolute;
				top:0;
				left:0;
				opacity: 0;
				visibility: hidden;
				transition: all .6s ease-out;
				z-index: 1;
			}
			 .color.active{
				opacity: 1;
				visibility: visible;
				transition-delay: 0ms;
				z-index: 2;
			}
			#color1{
				background:#8b2451;
			}
			#color2{
				background:#977F7F;
			}
			#color3{
				background:linear-gradient(225deg, rgba(2,72,66,1) 0%, rgba(0,81,76,1) 30%, rgba(0,108,110,1) 100%); 
			}
			#color4{
				background:linear-gradient(331deg, rgba(8,1,99,1) 0%, rgba(15,12,64,1) 70%, rgba(3,4,38,1) 100%);
			} */

			#sectionWrap{ width:100%; position: relative; z-index:2; }
			#sectionWrap .section{ width:100%; height:100vh; color:#fff; }
			#sectionWrap .section > span{ position: absolute; }
			#sectionWrap .section #balls{ width:100%; height:100%; position: relative; font-family: sans-serif; font-weight: 100; }
			#sectionWrap .section #balls .ballDiv{ width:19vh; position: absolute; cursor: pointer; opacity:0; visibility: hidden; }
			#sectionWrap .section #balls .ballDiv:after{ content:''; display:block; padding-top:100%; }
			#sectionWrap .section #balls .ballDiv span{ width: 100%; font-size:20px; color:#fff; text-align: center; position: absolute; top:50%; left:50%; transform: translate3d(-50%,-50%,0); }
			canvas{ position: fixed; top:0; left:0; display: block; z-index:1; }
		</style>
	</head>
	<body>
		<div id="sectionWrap">
			<div class="section">
				<span>1</span>
			</div>
			<div class="section"><span>2</span></div>
			<div class="section"><span>3</span>
				<div id="balls">
					<div class="ballDiv"><span>Real<br/>Estate</span></div>
					<div class="ballDiv"><span>Aircraft<br/>Leasing</span></div>
					<div class="ballDiv"><span>Education</span></div>
					<div class="ballDiv"><span>Health<br/>Care</span></div>
					<div class="ballDiv"><span>Energy</span></div>
					<div class="ballDiv"><span>Hospitality</span></div>
					<div class="ballDiv"><span>CTFE<br/>Ventures</span></div>
					<div class="ballDiv"><span>New World<br/>Group</span></div>
				</div>
			</div>
		</div>
		<div id="bgColor"></div>
		<script id="vertexShader" type="x-shader/x-vertex">
			uniform float time;
			uniform float size;
			void main()	{
				vec3 newPosition = position;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
				if(time > 0.){
					newPosition.x += (sin(newPosition.x + time * .2) * cos(newPosition.y + time * .2)) * .2;
					newPosition.y += (cos(newPosition.y + time * .2) * sin(newPosition.z + time * .2)) * .2;
					//newPosition.z += -cos(newPosition.z + time) * .04;
				}

				vec4 position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
				gl_Position = position;

				float x = pow(newPosition.x, 2.0);
				float y = pow(newPosition.y, 2.0);
				float z = pow(newPosition.z, 2.0);
				float dist = x + y + z;

				gl_PointSize = size + (dist / 100.);
			}
		</script>
	
		<script id="fragmentShader" type="x-shader/x-fragment">
			uniform sampler2D texture;
			//uniform vec3 fogColor;
			//uniform float fogNear;
			//uniform float fogFar;
			void main()	{
				vec4 textureColor = texture2D(texture, gl_PointCoord);
				if ( textureColor.w < .8 ) discard;
				gl_FragColor = vec4(255./255., 209./255., 150./255., .05) * textureColor;
				
				//#ifdef USE_LOGDEPTHBUF_EXT
				//	float depth = gl_FragDepthEXT / gl_FragCoord.w;
				//#else
				//	float depth = gl_FragCoord.z / gl_FragCoord.w;
				//#endif
				//float fogFactor = smoothstep( fogNear, fogFar, depth );
		  
				//gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
				//gl_FragColor.rgb = gl_FragColor.rgb;
			}
		</script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/105/three.min.js"></script>
        <script src="./LoaderSupport.js"></script>
		<script src="./OBJLoader2.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/2.1.2/TweenMax.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5/dat.gui.min.js"></script>
		<script src="./OrbitControls.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/chroma-js/2.0.3/chroma.min.js"></script>
		<script>

			//
			// Random
			//
			var random = function( min , max , isRound ){
				var ran = (Math.random() * (max - min)) + min;
				if(isRound)
					return Math.round(ran);
				else
					return ran;
			}

			//
			// Add, Remove and Has Class
			//
			var hasClass = function(el, className){
				if(el.classList)
					return el.classList.contains(className)
				else
					return !!el.className.match(new RegExp('(\\s|^)' + className + '(\\s|$)'))
			}

			var  addClass = function(el, className){
				if(el.classList)
					el.classList.add(className)
				else if(!hasClass(el, className)) el.className += " " + className
			}

			var removeClass = function(el, className){
				var isNodelist = (typeof el.length != 'undefined' && typeof el.item != 'undefined')
				if(isNodelist){
					var els = el;

					for(var i=0; els[i]; i++){
						if(els[i].classList)
							els[i].classList.remove(className)
						else if(hasClass(els[i], className)){
							var reg = new RegExp('(\\s|^)' + className + '(\\s|$)')
							els[i].className=els[i].className.replace(reg, ' ')
						}
					}
				}
				else{
					if(el.classList)
						el.classList.remove(className)
					else if(hasClass(el, className)){
						var reg = new RegExp('(\\s|^)' + className + '(\\s|$)')
						el.className=el.className.replace(reg, ' ')
					}
				}
			}


			var ballMaxPoints = 20496;
			var bgPoints = 1000;
			var modelMaxPoints = 100600;
			var started = false;
			var options = {};
			var scene, camera, renderer;
			var finallyPoint, bgPoint, model = [];
			var pointsGeometry, bgPointsGeometry, cubePointsGeometry;
			var pointsMaterial, uniforms;
			var ballPos = {targetPos:[],tempTargetPos:[]};
			var modelPos = {targetPos:[],tempTargetPos:[]};
			var objFiles = [
				['./models/CTF_Finance_Center_v03.obj', -10,	1.5],
				['./models/Airplane_v04.obj',	-4,		1],
				['./models/Brain_v07.obj', 		-12,	2],
				['./models/CTFE_project_stethoscope_R3.obj', 		-4,		1.7],
				['./models/CTFE_project_windmill_R3.obj', 		-8.7,	1.7],
				['./models/Trolley_v07.obj', 	-8,		1.2],
				['./models/Trolley_v06.obj', 	-8,		1.2],
				// ['./models/Hand_v05.obj', 		-7,		1.2],
				['./models/NWD_logo_v05.obj', 	-8,		1.6],
			];
			var latlog = [
				//lat, 			log,			name, 		fontSize, circleSize
				[32.694775,		129.425179,		'Japan',	-50,	  200],
				[34.4541416,	86.0706458,		'China',	-50,	  200],
				[36.2497092,	-113.7004455,	'U.S.',		-300,	  400],
				[54.2315724,	-13.4279228,	'U.K.',		50,		  150],
				[-24.9910822,	115.2154973,	'Australia',100,	  100]
			];
			var section = 0;
			var oldSection = 0;
			var ballDegree = 360/8;
			var loaded = false;

			var init = function(){
				scene = new THREE.Scene();
				scene.fog = new THREE.Fog( 0x000000, 53, 100 );
				scene.fog.color = new THREE.Color(0x8b2451);
				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 1000 );
				camera.position.z = 55;
				var dist = camera.position.z;
				var vFOV = THREE.Math.degToRad( camera.fov );
				screenHeight = 2 * Math.tan( vFOV / 2 ) * dist;
				screenwidth = screenHeight * camera.aspect;
				// var controls = new THREE.OrbitControls( camera );

				renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setClearColor( 0x000000, 0 );
				document.body.appendChild( renderer.domElement );


				options = {
					wave: false,
					lightHelper: false,
					point:{
						size:2.5,
						depth:.8
					},
					camera:{
						z:camera.position.z
					},
					// fogNear:scene.fog.near,
					// fogFar:scene.fog.far,
					ToModel1: function(){
						TweenMax.to('html,body',1,{scrollTop:0, ease:Power4.easeOut});
					},
					ToModel2: function(){
						TweenMax.to('html,body',1,{scrollTop:1 * window.innerHeight, ease:Power4.easeOut});
					},
					ToModel3: function(){
						TweenMax.to('html,body',1,{scrollTop:2 * window.innerHeight, ease:Power4.easeOut});
					}
				}

				window.addEventListener( 'resize', onWindowResize, false );
				function onWindowResize() {
					updateBallDiv();

					camera.aspect = window.innerWidth / window.innerHeight;
					camera.updateProjectionMatrix();
					renderer.setSize( window.innerWidth, window.innerHeight );
				}

				
				initGUI();
				initLoadOBJ();
				initParticle();
				initBg();
				initSection1();
				initSection2();
				initSection3();
				renderer.setAnimationLoop(function(){
					update();
					render();
				})
			}

			var initGUI = function(){
				var gui = new dat.GUI({width: 390});
					// gui.add(options.point, 'size').min(0).max(5).name('Size of particle');
					// gui.add(options.camera, 'z').min(0).max(100).name('Move Camera');
					// var _f = gui.addFolder('Fog');
					// _f.add(options, 'fogNear').min(.1).max(100).name('Near');
					// _f.add(options, 'fogFar').min(20).max(100).name('Far');
					// _f.open();
					gui.add(options, 'ToModel1').name('Go Section 1');
					gui.add(options, 'ToModel2').name('Go Section 2');
					gui.add(options, 'ToModel3').name('Go Section 3');
					gui.add(options, 'wave').name('Let\'s Wave!');
					// gui.add(options, 'lightHelper').name('Show light helper(section 1)');
			}

			var createTexture = function(color, text, fontSize, circleSize){
				var fixedSize = 1024;
				var actualSize = circleSize;
				var canvas = document.createElement('canvas');
				var ctx = canvas.getContext('2d');
				ctx.canvas.width = fixedSize;
				ctx.canvas.height = fixedSize;
				ctx.beginPath();
				ctx.arc(fixedSize/2, fixedSize/2, fixedSize/2, 0, 2 * Math.PI);
				ctx.fillStyle = color;
				ctx.fill();
				if(text){
					ctx.font = (actualSize + fontSize)+"px Arial";
					ctx.fillStyle = 'white';
					ctx.textAlign = "center";
					ctx.fillText(text, fixedSize/2 , fixedSize/2 + (actualSize + fontSize)/3 );
				}
				return canvas;
			}

			var initParticle = function(){
				pointsGeometry = new THREE.BufferGeometry();
				bgPointsGeometry = new THREE.BufferGeometry();
				modelPointsGeometry = new THREE.BufferGeometry();
				cubePointsGeometry = new THREE.BufferGeometry();
				

				uniforms = {
					time: { value: 0 },
					size: { value: options.point.size },
					texture:{
						type: "t",
						value: new THREE.CanvasTexture(createTexture('white'))//new THREE.TextureLoader().load('https://klevron.github.io/codepen/misc/star.png')
					},
					// fogColor:    { type: "c", value: scene.fog.color },
					// fogNear:     { type: "f", value: scene.fog.near },
					// fogFar:      { type: "f", value: scene.fog.far }
				};
				

				pointsMaterial = new THREE.ShaderMaterial({
					uniforms: uniforms,
					vertexShader: document.getElementById('vertexShader').textContent,
					fragmentShader: document.getElementById('fragmentShader').textContent,
					blending: THREE.AdditiveBlending,
					// depthTest: true,
					depthWrite: false,
					// transparent: true,
					// fog:true
				});
			}

			var initBg = function(){
				var positions = new Float32Array( bgPoints * 3 );
				tempBgPos = new Float32Array( bgPoints * 3 );
				var colors = new Float32Array( bgPoints * 3 );
				for(var i=0; i<bgPoints; i++){
					var pos = new THREE.Vector3(
						THREE.Math.randFloat(-10,10),
						THREE.Math.randFloat(-10,10),
						THREE.Math.randFloat(-10,10)
					);
					pos.toArray(positions,i*3);
					pos.toArray(tempBgPos,i*3);

					color = new THREE.Color(0xffffff);
					color.toArray(colors, i*3);
				}
				bgPointsGeometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
				bgPointsGeometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ));
				bgPoint = new THREE.Points( bgPointsGeometry, new THREE.PointsMaterial({ 
					size:.1, 
					color:0xffffff, 
					map:new THREE.CanvasTexture(createTexture('white')),
					transparent: true,
				}));
				scene.add(bgPoint);
			}



			var initSection1 = function(){
				var radius = 15;
				ballsLightsGroup = new THREE.Group();
				ballsGroup = new THREE.Group();
				var sphere = new THREE.IcosahedronGeometry(4.6,4);
				for(var i=0; i<8; i++){
					var ball = sphere.clone();
					var ballMesh = new THREE.Mesh( ball, new THREE.MeshPhongMaterial({ 
						color: 0x8b2451,
						shininess:0,
						specular: 0x01FFFC
					}));
					ballMesh.position.x = radius * Math.sin((ballDegree*i) * (Math.PI/180));
					ballMesh.position.y = radius * Math.cos((ballDegree*i) * (Math.PI/180));
					ballMesh.layers.set(i+1);
					ballsGroup.add(ballMesh);
				}
				ballsLightsGroup.add(ballsGroup);

				// lights
				lightsGroup = new THREE.Group();
				lightsHelperGroup = new THREE.Group();
				lightParms = [
					{
						position: new THREE.Vector3(-10,2,-7),
						intensity: 7,
						distance: 20,
						angle: .5
					},
					{
						position: new THREE.Vector3(0,0,5),
						intensity: 4,
						distance: 20,
						angle: .5
					},
					{
						position: new THREE.Vector3(0,0,-8),
						intensity: 10,
						distance: 18,
						angle: .5
					},
					{
						position: new THREE.Vector3(-5,3,-2),
						intensity: 4,
						distance: 30,
						angle: .6
					},
					{
						position: new THREE.Vector3(0,0,15),
						intensity: 5,
						distance: 22,
						angle: .35
					},
					{
						position: new THREE.Vector3(0,0,4),
						intensity: 4,
						distance: 18,
						angle: .6
					},
					{
						position: new THREE.Vector3(0,-8,3),
						intensity: 3,
						distance: 22,
						angle: .6
					},
					{
						position: new THREE.Vector3(0,0,13),
						intensity: 6,
						distance: 22,
						angle: .7
					}
				]
				for(var i=0; i<8; i++){
					if(lightParms[i]){
						var spotLight = new THREE.SpotLight( 0x669E23,lightParms[i].intensity, lightParms[i].distance, lightParms[i].angle, 1 );
						spotLight.position.copy(lightParms[i].position);
						spotLight.position.z = -50;
						spotLight.originalPosition = new THREE.Vector3();
						spotLight.originalPosition.copy(spotLight.position);
						spotLight.target = ballsGroup.children[i];
						spotLight.layers.set(i+1);
						lightsGroup.add(spotLight);

						var spotLightHelper = new THREE.SpotLightHelper( spotLight );
						lightsHelperGroup.add( spotLightHelper );

						var ambientLight = new THREE.AmbientLight( 0xffffff );
						ambientLight.layers.set(i+1);
						scene.add( ambientLight );
					}
				}
				lightsHelperGroup.visible = false;
				ballsLightsGroup.add(lightsGroup);
				ballsLightsGroup.add(lightsHelperGroup);

				// initial position
				var moveS1 = screenHeight * ((window.pageYOffset)/window.innerHeight);
				ballsLightsGroup.position.y = Math.max(0,moveS1*1.15);
				ballsLightsGroup.position.z = Math.min(0,-moveS1/2);
				scene.add(ballsLightsGroup);
			}



			var initSection2 = function(){
				// earth
				var geometry = new THREE.SphereGeometry(15,62,62);
				earthPoint = new THREE.Points( geometry , pointsMaterial );

				initLocation();

				var positions = new Float32Array( ballMaxPoints * 3 );
				var colors = new Float32Array( ballMaxPoints * 3 );
				for(var i=0; i<ballMaxPoints; i++){
					color = new THREE.Color(0xffffff);
					color.toArray(colors, i*3);

					if(earthPoint.geometry.vertices[i]){
						var pos = new THREE.Vector3(
							earthPoint.geometry.vertices[i].x,
							earthPoint.geometry.vertices[i].y,
							earthPoint.geometry.vertices[i].z
						);
					}
					else{
						var idx = THREE.Math.randInt(0,Math.round(earthPoint.geometry.vertices.length-1));
						var pos = new THREE.Vector3(
							earthPoint.geometry.vertices[idx].x,
							earthPoint.geometry.vertices[idx].y,
							earthPoint.geometry.vertices[idx].z
						);
					}
					pos.toArray(positions, i*3);
				}
				pointsGeometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
				pointsGeometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ));

				finallyPoint = new THREE.Points( pointsGeometry, pointsMaterial );
				finallyPoint.position.y = Math.min(0,screenHeight * ((window.pageYOffset - window.innerHeight)/window.innerHeight));
				finallyPoint.position.z = -10;
				scene.add(finallyPoint);
			}



			var initLocation = function(){
				var locationPointGeometry = new THREE.BufferGeometry();
				var locationPositions = new Float32Array( latlog.length * 3 );
				var locationSize = new Float32Array( latlog.length );
				var textureIdx = new Float32Array(latlog.length);
				var textures = [];			

				for(var i=0; latlog[i]; i++){
					var p = calcPosFromLatLonRad(latlog[i][0],latlog[i][1],15);
					for(var j=0; j<3; j+=3){
						var array = new THREE.Vector3(p[0], p[1], p[2]);
						array.toArray(locationPositions, i*3);
					}
					textures[i] = new THREE.CanvasTexture(createTexture('#8b2451',latlog[i][2],latlog[i][3],latlog[i][4]));
					textures[i].flipY = false;
					locationSize[i] = latlog[i][4];
					textureIdx[i] = i;
				}

				locationPointGeometry.addAttribute( 'position', new THREE.BufferAttribute( locationPositions, 3 ) );
				locationPointGeometry.addAttribute( 'locationSize', new THREE.BufferAttribute( locationSize, 1 ) );
				locationPointGeometry.addAttribute( 'textureIdx', new THREE.BufferAttribute( textureIdx, 1 ) );


				var locationPointsMaterial = new THREE.ShaderMaterial({
					uniforms: {
						size: { type:'f', value: .0 },
						textures:{
							type:'tv',
							value: textures,
						}
					},
					vertexShader: [
						'attribute float locationSize;',
						'attribute float textureIdx;',
						
						'varying float vTextureIdx;',

						'uniform float size;',

						'void main(){',
							'vTextureIdx = textureIdx;',
							'vec4 position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);',
							'gl_Position = position;',
							'gl_PointSize = locationSize * size;',
						'}'
					].join('\n'),
					fragmentShader: [
						'varying float vTextureIdx;',

						'uniform sampler2D textures['+textures.length+'];',

						'void main(){',
							'vec4 textureColor;',
							'if(vTextureIdx < .5){',
								'textureColor = texture2D(textures[0], gl_PointCoord);',
							'}else if(vTextureIdx < 1.5){',
								'textureColor = texture2D(textures[1], gl_PointCoord);',
							'}else if(vTextureIdx < 2.5){',
								'textureColor = texture2D(textures[2], gl_PointCoord);',
							'}else if(vTextureIdx < 3.5){',
								'textureColor = texture2D(textures[3], gl_PointCoord);',
							'}else if(vTextureIdx < 4.5){',
								'textureColor = texture2D(textures[4], gl_PointCoord);',
							'}',

							'if ( textureColor.w < .8 ) discard;',
							'gl_FragColor = vec4(1., 1., 1., 1.) * textureColor;',
						'}'
					].join('\n'),
					// blending: THREE.AdditiveBlending,
					// depthTest: false,
					// depthWrite: true,
					transparent: true,
					// fog:true
				});
				locationPoint = new THREE.Points( locationPointGeometry, locationPointsMaterial );
				scene.add(locationPoint);
			}


			var initSection3 = function(){
				var radius = 14;
				var combined = new THREE.Geometry();
				var sphere = new THREE.IcosahedronGeometry(4.3,4);
				for(var i=0; i<8; i++){
					var ball = sphere.clone();
					var ballMesh = new THREE.Points( ball, new THREE.MeshBasicMaterial() );
					ballMesh.position.x = radius * Math.sin((ballDegree*i) * (Math.PI/180));
					ballMesh.position.y = radius * Math.cos((ballDegree*i) * (Math.PI/180));
					ballMesh.rotation.z = THREE.Math.randFloat(-1,1);
					ballMesh.updateMatrix();
					combined.merge( ballMesh.geometry , ballMesh.matrix );
				}
				ballsPoint = new THREE.Points( combined, new THREE.PointsMaterial({ 
					size:.15,
					color: 0xffffff,
					transparent:true
				}));



				// cube point position
				var positions = new Float32Array( modelMaxPoints * 3 );
				for(var i=0; i<modelMaxPoints; i++){
					var pos = new THREE.Vector3(
						THREE.Math.randFloat(-30,30),
						THREE.Math.randFloat(-20,20),
						THREE.Math.randFloat(-30,30)
					);
					pos.toArray(positions,i*3);
				}
				cubePointsGeometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
				cubePoints = new THREE.Points( cubePointsGeometry, new THREE.MeshBasicMaterial() );



				var positions = new Float32Array( modelMaxPoints * 3 );
				for(var i=0; i<modelMaxPoints; i++){
					var pos = new THREE.Vector3(
						cubePoints.geometry.attributes.position.array[i*3+0],
						cubePoints.geometry.attributes.position.array[i*3+1],
						cubePoints.geometry.attributes.position.array[i*3+2]
					);
					pos.toArray(positions, i*3);
				}
				modelPointsGeometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );

				var uniforms = {
					opacity:{
						value: 0
					},
					size:{
						value:3
					},
					texture:{
						type: "t",
						value: new THREE.CanvasTexture(createTexture('white'))//new THREE.TextureLoader().load('https://klevron.github.io/codepen/misc/star.png')
					}
				}

				var modelPointsMaterial = new THREE.ShaderMaterial({ 
					uniforms: uniforms,
					vertexShader: [
						'uniform float size;',
						'void main(){',
							'vec3 newPosition = position;',
							'vec4 position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);',
							'gl_Position = position;',

							'float x = pow(newPosition.x, 2.0);',
							'float y = pow(newPosition.y, 2.0);',
							'float z = pow(newPosition.z, 2.0);',
							'float dist = x + y + z;',
							'gl_PointSize = size - dist / 10000.;',
						'}'
					].join('\n'),
					fragmentShader: [
						'uniform sampler2D texture;',
						'uniform float opacity;',
						'void main(){',
							'vec4 textureColor = texture2D(texture, gl_PointCoord);',

							'if ( textureColor.w < .8 ) discard;',
							'gl_FragColor = vec4(1., 1., 1., opacity) * textureColor;',
						'}'
					].join('\n'),
					blending: THREE.AdditiveBlending,
					depthWrite: false,
				});

				modelPoint = new THREE.Points( modelPointsGeometry, modelPointsMaterial);
				modelPoint.scale.set(1.2, 1.2, 1.2);
				scene.add(modelPoint);


				// init div
				initBallDiv();
			}

			var initBallDiv = function(){
				ballDiv = document.querySelectorAll('.ballDiv');
				initBallDivEvent();
				updateBallDiv();
			}
			var initBallDivEvent = function(){
				for(var i=0; i<ballDiv.length; i++){
					(function(idx){
						var idx = idx;
						ballDiv[idx].addEventListener('mouseenter',function(){
							if(model[idx])
								modelPos = morphTo(modelPoint, model[idx], modelMaxPoints);
							
							TweenMax.to(ballDiv, 1, {autoAlpha: 0.3, overwrite:'all', ease:Power4.easeOut});
							TweenMax.to(this, 1, {autoAlpha: 1, overwrite:'all', ease:Power4.easeOut});
							TweenMax.to(modelPoint.material.uniforms.opacity, 2, {value: .2, ease:Power4.easeOut});
						},false);

						ballDiv[idx].addEventListener('mouseleave',function(){
							TweenMax.to(ballDiv, .6, {autoAlpha: 1, ease:Power4.easeOut, onComplete(){
								modelPos = morphTo(modelPoint, cubePoints, modelMaxPoints);
								TweenMax.to(modelPoint.material.uniforms.opacity, 2, {value: 0, ease:Power4.easeOut});
							}});
						},false);
					})(i);
				}
			}
			var updateBallDiv = function(){
				radius = window.innerHeight * .31;
				for(var i=0; i<ballDiv.length; i++){
					var w = ballDiv[i].offsetWidth;
					ballDiv[i].style.left = (radius * Math.sin((-ballDegree*i - 180) * (Math.PI/180)) + (window.innerWidth/2)-(w/2)) / 16 + 'rem';
					ballDiv[i].style.top = (radius * Math.cos((ballDegree*i - 180) * (Math.PI/180)) + (window.innerHeight/2)-(w/2)) / 16 + 'rem';
				}
			}


            var initLoadOBJ = function(){
				var loadingProgress = 0;
				var div = document.createElement('div');
				div.style.position = 'fixed';
				div.style.top = '50%';
				div.style.left = '50%';
				div.style.transform = 'translate3d(-50%,50%,0);';
				div.style.webkitTransform = 'translate3d(-50%,50%,0);';
				div.innerHTML = '0%';
				document.body.appendChild(div);


				var manager = new THREE.LoadingManager();

				// all objects are loaded
				manager.onLoad = function(){
					console.log( 'Loading complete!');


					// light
					var tl = new TimelineMax();
					for(var i=0; i<lightsGroup.children.length; i++){
						tl.to(lightsGroup.children[i].position, 3, {z:lightParms[i].position.z, ease:Power4.easeOut},'s');
					}

					div.remove();

					loaded = true;
				};


				// load .obj file
				var loadObj = function(idx, file, reposition, scale){
					var loader = new THREE.OBJLoader2(manager);
					loader.load(file, function(obj){
						var geometry = obj.detail.loaderRootNode;
						geometry.traverse(function(child){
							if ( child instanceof THREE.Mesh ){
								// change to geometry
								var geo = new THREE.Geometry().fromBufferGeometry( child.geometry );
								geo.mergeVertices();
								model[idx] = new THREE.Points( geo , pointsMaterial );
								model[idx].scale.set(scale,scale,scale);
								model[idx].updateMatrix();
								model[idx].geometry.applyMatrix( model[idx].matrix );
								for(var i=0; model[idx].geometry.vertices[i]; i++){
									model[idx].geometry.vertices[i].y += reposition;
								}
								console.log('model'+(idx+1)+': ',model[idx].geometry.vertices.length, model[idx]);
								loadingProgress += 100/objFiles.length;
								div.innerHTML = Math.min(100,loadingProgress)+'%';
							}
						});
					}, null, null, null, false );
				}

				// loop all files
				for(var i=0; objFiles[i]; i++){
					loadObj(i, objFiles[i][0], objFiles[i][1], objFiles[i][2]);
				}
            }

			
			var morphTo = function(fromMesh, toMesh, maxPoints){
				var pos = fromMesh.geometry.attributes.position.array;
				var isGeometry;
				var posArray;
				var toMesh = toMesh;
				var targetGeoPos = [];
				var tempTargetGeoPos = [];
				toMesh.traverse(function(child){
					if ( child.geometry instanceof THREE.Geometry ){
						isGeometry = true;
					}
					else{
						isGeometry = false;
						posArray = child.geometry.attributes.position.array;
					}
				});
				for(var i=0; i<maxPoints; i++){
					targetGeoPos[i] = {
						x: THREE.Math.randFloat(-15,15),
						y: THREE.Math.randFloat(-15,15),
						z: THREE.Math.randFloat(-15,15)
					}
					if(isGeometry){
						if(i < toMesh.geometry.vertices.length){
							tempTargetGeoPos[i] = {
								x: toMesh.geometry.vertices[i].x,
								y: toMesh.geometry.vertices[i].y,
								z: toMesh.geometry.vertices[i].z
							};
						}
						else{
							var idx = THREE.Math.randInt(0,toMesh.geometry.vertices.length-1);
							tempTargetGeoPos[i] = {
								x: toMesh.geometry.vertices[idx].x,
								y: toMesh.geometry.vertices[idx].y,
								z: toMesh.geometry.vertices[idx].z
							};
						}
					}
					else{
						if(i < Math.round(posArray.length/3)){
							tempTargetGeoPos[i] = {
								x: posArray[i*3+0],
								y: posArray[i*3+1],
								z: posArray[i*3+2]
							};
						}
						else{
							var idx = THREE.Math.randInt(0,Math.round(posArray.length/3));
							tempTargetGeoPos[i] = {
								x: toMesh.geometry.vertices[idx].x,
								y: toMesh.geometry.vertices[idx].y,
								z: toMesh.geometry.vertices[idx].z
							};
						}
					}
				}
				return {
					targetPos: targetGeoPos,
					tempTargetPos: tempTargetGeoPos
				}

				// targetPos = tempTargetPos;
				// update bg color
				// removeClass(document.querySelector('.color.active'),'active');
				// addClass(document.querySelector(bgColor), 'active');

				// update fog color
				// scene.fog.color = new THREE.Color(fogColor);
				// options.fogNear = fog.near != undefined ? fog.near : 25;
				// options.fogFar = fog.far != undefined ? fog.far : 50;
			}


			var updateSection = function(section){
				if(section == 1){
					TweenMax.to(locationPoint.material.uniforms.size, .6, {value: 0, overwrite:'all', ease:Power4.easeOut});
					scene.fog.color = new THREE.Color(0x8b2451);
					TweenMax.to('#bgColor', 1, {backgroundColor: '#8b2451', overwrite:'all', ease:Power3.easeOut});
				}
				else if(section == 2){
					TweenMax.to(locationPoint.material.uniforms.size, 2, {value: 1, ease:Elastic.easeOut.config(1, 0.3)});
					scene.fog.color = new THREE.Color(0x977F7F);
					TweenMax.to('#bgColor', 1, {backgroundColor: '#977F7F', overwrite:'all', ease:Power3.easeOut});
					if(oldSection == 3)
						ballPos = morphTo(finallyPoint, earthPoint, ballMaxPoints);

					TweenMax.staggerTo('.ballDiv', .2, {autoAlpha: 0, ease:Power4.easeOut});
				}
				else if(section == 3){
					TweenMax.to(locationPoint.material.uniforms.size, .6, {value: 0, overwrite:'all', ease:Power4.easeOut});
					scene.fog.color = new THREE.Color(0xFE736C);
					TweenMax.to('#bgColor', 1, {backgroundColor: '#FE736C', overwrite:'all', ease:Power3.easeOut});
					ballPos = morphTo(finallyPoint, ballsPoint, ballMaxPoints);

					newdeltaMove.x = 0;
					newdeltaMove.y = 0;
					finallyPoint.rotation.x = 0;
					finallyPoint.rotation.y = 0;
					finallyPoint.rotation.z = 0;

					TweenMax.staggerTo('.ballDiv', 1, {delay:1, autoAlpha: 1, overwrite:'all', ease:Power3.easeOut},.08);
				}
				oldSection = section;
			}


			var start = Date.now();
            var update = function () {
				var timer = (Date.now() - start) / 10000;

				// if all loaded
				if(loaded){

					// Conver 2d position to 3d position
					var vector = new THREE.Vector3(_mouse.x, _mouse.y, 0.5);
					vector.unproject( camera );
					var dir = vector.sub( camera.position ).normalize();
					var distance = - camera.position.z / dir.z;
					mouse = camera.position.clone().add( dir.multiplyScalar( distance ) );


					// update section with scroll
					if(window.pageYOffset >= (section * window.innerHeight)){
						section++;
						updateSection(section);
					}
					else if(window.pageYOffset < ((section-1) * window.innerHeight)){
						section--;
						updateSection(section);
					}


					// drag the earth and location
					if(section <= 2){
						var deltaRotationQuaternion = new THREE.Quaternion().setFromEuler(
							new THREE.Euler(
								toRadians(newdeltaMove.y * .3),
								toRadians(newdeltaMove.x * .3),
								0,
								'XYZ'
							)
						);
						locationPoint.quaternion.multiplyQuaternions(deltaRotationQuaternion, locationPoint.quaternion);
						finallyPoint.quaternion.multiplyQuaternions(deltaRotationQuaternion, finallyPoint.quaternion);
						// finallyPoint.updateMatrix(); 
						// finallyPoint.geometry.applyMatrix( finallyPoint.matrix );
						// finallyPoint.matrix.identity();
						// finallyPoint.rotation.set(0,0,0);
						// finallyPoint.updateMatrix(); 
					}


					// move light in section 1
					if(mouseenter){
						for(var i=0; i<lightsGroup.children.length; i++){
							var lightX = lightsGroup.children[i].originalPosition.x + mouse.x * .2;
							var lightY = lightsGroup.children[i].originalPosition.y + mouse.y * .2;

							// easing
							lightsGroup.children[i].position.x += (lightX - lightsGroup.children[i].position.x) * .1;
							lightsGroup.children[i].position.y += (lightY - lightsGroup.children[i].position.y) * .1;
						}
					}


					var bpos = finallyPoint.geometry.attributes.position.array;
					for(var i=0; i<ballMaxPoints; i++){
						if(ballPos.targetPos.length){
							ballPos.targetPos[i].x += (ballPos.tempTargetPos[i].x - ballPos.targetPos[i].x) * .04;
							ballPos.targetPos[i].y += (ballPos.tempTargetPos[i].y - ballPos.targetPos[i].y) * .04;
							ballPos.targetPos[i].z += (ballPos.tempTargetPos[i].z - ballPos.targetPos[i].z) * .04;
							
							bpos[i*3+0] += (ballPos.targetPos[i].x - bpos[i*3+0]) * .04;
							bpos[i*3+1] += (ballPos.targetPos[i].y - bpos[i*3+1]) * .04;
							bpos[i*3+2] += (ballPos.targetPos[i].z - bpos[i*3+2]) * .04;
						}
					}


					var mpos = modelPoint.geometry.attributes.position.array;
					for(var i=0; i<modelMaxPoints; i++){
						if(modelPos.targetPos.length){

							// modelPos.targetPos[i].x += (modelPos.tempTargetPos[i].x - modelPos.targetPos[i].x) * .04;
							// modelPos.targetPos[i].y += (modelPos.tempTargetPos[i].y - modelPos.targetPos[i].y) * .04;
							// modelPos.targetPos[i].z += (modelPos.tempTargetPos[i].z - modelPos.targetPos[i].z) * .04;
							
							mpos[i*3+0] += (modelPos.tempTargetPos[i].x - mpos[i*3+0]) * .04;
							mpos[i*3+1] += (modelPos.tempTargetPos[i].y - mpos[i*3+1]) * .04;
							mpos[i*3+2] += (modelPos.tempTargetPos[i].z - mpos[i*3+2]) * .04;
						}
					}



					if(options.wave)
						finallyPoint.material.uniforms.time.value+=.05;
					else
						finallyPoint.material.uniforms.time.value = 0;

					var moveS1 = screenHeight * ((window.pageYOffset)/window.innerHeight);
					var moveS2 = screenHeight * ((window.pageYOffset - window.innerHeight)/window.innerHeight);


					ballsLightsGroup.position.y += (Math.max(0,moveS1*1.15) - ballsLightsGroup.position.y) * .1;
					ballsLightsGroup.position.z += (Math.min(0,-moveS1/2) - ballsLightsGroup.position.z) * .1;


					finallyPoint.position.y += (Math.min(0,moveS2) - finallyPoint.position.y) * .1;
					finallyPoint.position.z += (Math.max(0,-moveS2 * 1.5) - finallyPoint.position.z) * .1;
					finallyPoint.geometry.attributes.position.needsUpdate = true;
					finallyPoint.material.uniforms.size.value = Math.max(5,-moveS2) + (.5 * Math.max(0,-moveS2));

					locationPoint.position.y += (Math.min(0,moveS2) - locationPoint.position.y) * .1;
					locationPoint.position.z += (Math.max(0,-moveS2 * 1.5) - locationPoint.position.z) * .1;


					modelPoint.rotation.y = -timer;
					modelPoint.geometry.attributes.position.needsUpdate = true;
					modelPoint.material.uniforms.size.value = options.point.size;
				}


				//
				if(bgPoint){
					bgPoint.rotation.y = -timer/2;
					var bgpos = bgPointsGeometry.attributes.position.array;
					for(var i=0; i<bgPoints; i++){
						bgpos[i*3+0] = 40 * Math.sin(tempBgPos[i*3+0] + timer*.4);
						bgpos[i*3+1] = 40 * Math.cos(tempBgPos[i*3+1] + timer*.1);
						bgpos[i*3+2] = 40 * Math.cos(tempBgPos[i*3+2] + timer*.2);
					}
					bgPointsGeometry.attributes.position.needsUpdate = true;
				}

				// lights helper
				for(var i=0; i<lightsHelperGroup.children.length; i++){
					lightsHelperGroup.children[i].update();
				}

				lightsHelperGroup.visible = options.lightHelper;
			};
			
			var render = function(){
				// scene.fog.near = options.fogNear;
				// scene.fog.far = options.fogFar;
				camera.position.z = options.camera.z;

				renderer.autoClear = true;
				camera.lookAt(new THREE.Vector3(0,0,0));
				camera.layers.set(0);
				renderer.render( scene, camera );

				for(var i=0; i<ballsGroup.children.length; i++){
					renderer.autoClear = false;

					camera.layers.set(i+1); // << == switch camera between layers
					renderer.render(scene, camera);
				}
			}


			var mouseenter = false;
			var clicked = false;
			var currentPos = {x:0,y:0};
			var prevPos = {x:0,y:0};
			var mouse = {x:0,y:0};
			var deltaMove = {x:0,y:0};
			var newdeltaMove = {x:-0.1,y:0.1};
			var _mouse = {};
			window.addEventListener('mousemove',function(event){
				mouseenter = true;
				// Update the mouse variable
				// <-   width  ->
				// -1     0     1
				deltaMove = {
					x:event.clientX - prevPos.x,
					y:event.clientY - prevPos.y
				}
				if(clicked){
					newdeltaMove.x += ( Math.min(2,Math.max(-2,deltaMove.x)) - newdeltaMove.x) * .1;
					newdeltaMove.y += ( Math.min(2,Math.max(-2,deltaMove.y)) - newdeltaMove.y) * .1;
				}
				prevPos = {
					x:event.clientX,
					y:event.clientY
				}
				_mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				_mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
			}, false);

			window.addEventListener('mousedown',function(event){
				clicked = true;
				prevPos = {
					x:event.clientX,
					y:event.clientY
				}
				
			})
			window.addEventListener('mouseup',function(event){
				clicked = false;
			});
			document.addEventListener('mouseenter',function(event){
				mouseenter = true;
			});
			document.addEventListener('mouseleave',function(event){
				mouseenter = false;
				for(var i=0; i<lightsGroup.children.length; i++){
					TweenMax.to(lightsGroup.children[i].position,1,{x: lightsGroup.children[i].originalPosition.x, y:lightsGroup.children[i].originalPosition.y, ease:Power3.easeOut});
				}
			});

			var toRadians = function(angle){
				return angle * (Math.PI / 180);
			}



			var calcPosFromLatLonRad = function(lat,lon,radius){
				var phi   = (90-lat)*(Math.PI/180)
				var theta = (lon+180)*(Math.PI/180)

				x = -((radius) * Math.sin(phi)*Math.cos(theta))
				z = ((radius) * Math.sin(phi)*Math.sin(theta))
				y = ((radius) * Math.cos(phi))

				return [x,y,z]
			}
			
			init();
		</script>
	</body>
</html>