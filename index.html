<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>particles</title>
		<style>
			html,body{ overflow: hidden; }
			body { padding:0; margin: 0; }
			canvas { width: 100%; height: 100%; }
		</style>
	</head>
	<body>
		<script id="vertexShader" type="x-shader/x-vertex">
			attribute vec3 color;
			varying vec4 vColor;
			uniform float time;
			uniform float size;
			void main()	{
				vec3 newPosition = position;
				newPosition.x += sin(newPosition.x + time) * .1;
				newPosition.y += -cos(newPosition.y + time) * .1;
				newPosition.z += -cos(newPosition.z + time) * .1;

				vec4 position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
				gl_Position = position;

				vColor = vec4(color,1.);
				gl_PointSize = size;
			}
		</script>
	
		<script id="fragmentShader" type="x-shader/x-fragment">
			varying vec4 vColor;
			uniform sampler2D texture;
			uniform vec3 fogColor;
			uniform float fogNear;
			uniform float fogFar;
			void main()	{
				gl_FragColor = vColor * texture2D(texture, gl_PointCoord);
				#ifdef USE_LOGDEPTHBUF_EXT
					float depth = gl_FragDepthEXT / gl_FragCoord.w;
				#else
					float depth = gl_FragCoord.z / gl_FragCoord.w;
				#endif
				float fogFactor = smoothstep( fogNear, fogFar, depth );
		  
				gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
			}
		</script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/105/three.min.js"></script>
        <script src="./LoaderSupport.js"></script>
		<script src="./OBJLoader2.js"></script>
		<!-- <script src="http://dev.miaumiau.cat/curl_particles_collision/js/CameraControl.js"></script> -->
		<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/2.1.2/TweenMax.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5/dat.gui.min.js"></script>
		<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/controls/OrbitControls.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/chroma-js/2.0.3/chroma.min.js"></script>
		<script>
			var maxPoints = 14904;

            var scene = new THREE.Scene();
				scene.fog = new THREE.Fog( 0x000000, 0.1, 30 );
			var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
			camera.position.z = 22;
			// var controls = new THREE.OrbitControls( camera );

            var renderer = new THREE.WebGLRenderer( { antialias: true } );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setClearColor( 0x000000, 1 );
			document.body.appendChild( renderer.domElement );

			// light
            var ambientLight = new THREE.AmbientLight( 0x222222 );
            scene.add( ambientLight );
            var lights = [];
			lights[ 0 ] = new THREE.PointLight( 0xff0000, 1, 0 );
			lights[ 1 ] = new THREE.PointLight( 0x00ff00, 1, 0 );
			lights[ 2 ] = new THREE.PointLight( 0x0000ff, 1, 0 );

			lights[ 0 ].position.set( -22, 0, 22 );
			lights[ 1 ].position.set( 22, 0, 22 );
			lights[ 2 ].position.set( 0, 0 , 22 );

			scene.add( lights[ 0 ] );
			scene.add( lights[ 1 ] );
			scene.add( lights[ 2 ] );

			var options = {
				wave: false,
				point:{
					size:30,
					depth:.8
				},
				camera:{
					z:camera.position.z
				},
				fogNear:scene.fog.near,
				fogFar:scene.fog.far,
				deerToRabbit: function(){
					morphTo(rabbitPoint);
				},
				RabbitToDeer: function(){
					morphTo(deerPoint);
				}
			}
			var gui = new dat.GUI({width: 300});
			gui.add(options.point, 'size').min(1).max(100).name('Size of point');
			// gui.add(options.point, 'depth').min(.1).max(5).name('Depth of point');
			gui.add(options.camera, 'z').min(0).max(50).name('Move Camera');
			var _f = gui.addFolder('Fog');
			_f.add(options, 'fogNear').min(.1).max(20).name('Near');
			_f.add(options, 'fogFar').min(20).max(60).name('Far');
			_f.open();
			gui.add(options, 'deerToRabbit').name('morph to üêá');
			gui.add(options, 'RabbitToDeer').name('morph to üçê');
			gui.add(options, 'wave').name('wave');

			
			function generateCircularSprite(color) {
				var canvas = document.createElement('canvas');
				canvas.height = 100;
				canvas.width = 100;
				var context = canvas.getContext('2d');
				var centerX = canvas.width / 2;
				var centerY = canvas.height / 2;
				var radius = 50;

				context.beginPath();
				context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);
				context.fillStyle = "rgba(255, 255, 255, 0.9)";
				context.fill();
				return canvas;
			}
			var pointsGeometry = new THREE.BufferGeometry();
			var pointsMaterial;
			var finallyPoint;
			var deerPoint,rabbitPoint;
			var color = 0xff00ff;
			var uniforms = {
				time: { value: 0 },
				size: { value: options.point.size },
				// depth: { value: options.point.depth },
				texture:{
					type: "t",
					value: new THREE.TextureLoader().load('https://klevron.github.io/codepen/misc/star.png')
				},
				fogColor:    { type: "c", value: scene.fog.color },
				fogNear:     { type: "f", value: scene.fog.near },
				fogFar:      { type: "f", value: scene.fog.far }
			};
			

			var pointsMaterial = new THREE.ShaderMaterial({
				uniforms: uniforms,
				vertexShader: document.getElementById('vertexShader').textContent,
				fragmentShader: document.getElementById('fragmentShader').textContent,
				blending: THREE.AdditiveBlending,
				depthTest: true,
    			depthWrite: false,
				transparent: true,
				fog:true
			});

			// var changeColor = function(value){
			// 	var value = new THREE.Color(value);
			// 	var c = new THREE.Color(finallyPoint.material.color.getHex());
			// 	TweenLite.to(c, 1, {
			// 		r: value.r,
			// 		g: value.g,
			// 		b: value.b,
			// 		ease: Cubic.easeInOut,
			// 		onUpdate: function(){ finallyPoint.material.color = c; }
			// 	});
			// }

            var loadOBJ = function(){
				var manager = new THREE.LoadingManager();
				manager.onLoad = function(){
					console.log( 'Loading complete!');

					// init
					var cscale = chroma.scale([0x00b9e0, 0xff880a, 0x5f1b90, 0x7ec08d]);
					var positions = new Float32Array( maxPoints * 3 );
					alphas = new Float32Array( maxPoints * 1 );
					colors = new Float32Array( maxPoints * 3 );
					for(var i=0; i<maxPoints; i++){
						color = new THREE.Color(cscale(THREE.Math.randFloat(0, 1)).hex());
						color.toArray(colors, i*3);
					}
					pointsGeometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
					pointsGeometry.addAttribute( 'alpha', new THREE.BufferAttribute( alphas, 1 ));
					pointsGeometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ));

					morphTo(rabbitPoint);
					// console.log(target,pointsGeometry.attributes.position,positions,plane);

					// pointsMaterial = new THREE.PointsMaterial( { color: 0xffff00, size:.1 } );
					finallyPoint = new THREE.Points( pointsGeometry, pointsMaterial );
					finallyPoint.position.y = -8;
					finallyPoint.rotation.y = 15;
					finallyPoint.scale.set(3,3,3);
					scene.add(finallyPoint);
				};
				var loader = new THREE.OBJLoader2(manager);
                loader.load( './model2.obj', function ( obj ) {
					var geometry = obj.detail.loaderRootNode;
					geometry.traverse( function( child ) {
						if ( child instanceof THREE.Mesh ) {
							// change to geometry
							var geo = new THREE.Geometry().fromBufferGeometry( child.geometry );

							deerPoint = new THREE.Points( geo, pointsMaterial );
							console.log('pear: ',deerPoint.geometry.vertices.length);
						}
					});
                }, null, null, null, false );


				loader = new THREE.OBJLoader2(manager);
				loader.load( './model1.obj', function ( obj ) {
					var geometry = obj.detail.loaderRootNode;
					geometry.traverse( function( child ) {
						if ( child instanceof THREE.Mesh ) {
							// child.material = pointsMaterial;
							// child.position.x = 16;
							// child.position.y = -4;

							// change to geometry
							var geo = new THREE.Geometry().fromBufferGeometry( child.geometry );

							rabbitPoint = new THREE.Points( geo , pointsMaterial );
							console.log('rabbit: ',rabbitPoint.geometry.vertices.length);
						}
					});
				}, null, null, null, false );
            }
			loadOBJ();

			var targetMesh;
			var target = [];
			var morphTo = function(mesh){
				var pos = pointsGeometry.attributes.position.array;
				targetMesh = mesh;
				for(var i=0; i<maxPoints; i++){
					if(targetMesh.geometry.vertices[i]){
						target[i] = {
							x:mesh.geometry.vertices[i].x,
							y:mesh.geometry.vertices[i].y,
							z:mesh.geometry.vertices[i].z
						};
						// pos[i*3+0] = mesh.geometry.vertices[i].x;
						// pos[i*3+1] = mesh.geometry.vertices[i].y;
						// pos[i*3+2] = mesh.geometry.vertices[i].z;
						// TweenMax.to(pointsGeometry.vertices[i],2,{
						// 	'x':mesh.geometry.vertices[i].x,
						// 	'y':mesh.geometry.vertices[i].y,
						// 	'z':mesh.geometry.vertices[i].z,
						// 	ease:Power4.easeInOut
						// });
						// alphas[i] = 1.0;
					}
					else{
						target[i] = {
							x:THREE.Math.randFloat(-100,100),
							y:THREE.Math.randFloat(-100,100),
							z:THREE.Math.randFloat(-100,100)
						};
						// TweenMax.to(pointsGeometry.vertices[i],2,{
						// 	'x':mesh.geometry.vertices[0].x,
						// 	'y':mesh.geometry.vertices[0].y,
						// 	'z':mesh.geometry.vertices[0].z,
						// 	ease:Power4.easeInOut
						// });
						//  alphas[i] = 0.0;
					}
				}
			}

			var started = false;
			var start = Date.now();
			// var done = false;
            var animate = function () {
				requestAnimationFrame( animate );

				var timer = (Date.now() - start) * .00005;

				if(targetMesh){
					var pos = pointsGeometry.attributes.position.array;
					var alpha = pointsGeometry.attributes.alpha.array;
					for(var i=0; i<maxPoints; i++){
						if(targetMesh.geometry.vertices[i]){
							pos[i*3+0] += (target[i].x - pos[i*3+0]) * .1;
							pos[i*3+1] += (target[i].y - pos[i*3+1]) * .1;
							pos[i*3+2] += (target[i].z - pos[i*3+2]) * .1;
							
							// alphas[i] = 0.0;
						}
						else{
							pos[i*3+0] += (target[i].x - pos[i*3+0]) * ((started)?.1:1);
							pos[i*3+1] += (target[i].y - pos[i*3+1]) * ((started)?.1:1);
							pos[i*3+2] += (target[i].z - pos[i*3+2]) * ((started)?.1:1);

							// alphas[i] = 0.0;
						}
					}
					if(!started) started = true;
				}
				// 
				if(finallyPoint){
					finallyPoint.rotation.y-=.005;
					if(options.wave){
						TweenMax.killAll();
						finallyPoint.material.uniforms.time.value+=.05;
					}
					else
						TweenMax.set(finallyPoint.material.uniforms.time,{value:0});

					finallyPoint.material.uniforms.size.value = options.point.size;
					scene.fog.near = options.fogNear;
					scene.fog.far = options.fogFar;
				}


				camera.position.z = options.camera.z;
				// camera.position.x = (Math.sin(timer)*30);
				// camera.position.z = -(Math.cos(timer)*30);

				if(pointsGeometry.attributes.position) pointsGeometry.attributes.position.needsUpdate = true;
				if(pointsGeometry.attributes.alpha) pointsGeometry.attributes.alpha.needsUpdate = true;
				if(pointsGeometry.attributes.color) pointsGeometry.attributes.color.needsUpdate = true;

				camera.lookAt(new THREE.Vector3(0,0,0));
                // controls.update();
				renderer.render( scene, camera );
            };
            animate();

			// var geometry = new THREE.BoxGeometry( 3, 3, 3 );
			// var material = new THREE.MeshLambertMaterial( {color: 0x00ff00} );
			// var cube = new THREE.Mesh( geometry, material );
			// cube.rotation.y = 10;
			// cube.rotation.x = 10;
			// scene.add( cube );

			//
			// Random
			//
			var random = function( min , max , isRound ){
				var ran = (Math.random() * (max - min)) + min;
				if(isRound)
					return Math.round(ran);
				else
					return ran;
			}

		</script>
	</body>
</html>