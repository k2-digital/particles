<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>particles</title>
		<style>
			html,body{ overflow: hidden; }
			body { padding:0; margin: 0; position: relative; background:#000; }
			.color{
				width:100%;
				height:100%;
				position: absolute;
				top:0;
				left:0;
				opacity: 0;
				visibility: hidden;
				transition: all .6s ease-out;
				z-index: 1;
			}
			.color.active{
				opacity: 1;
				visibility: visible;
				transition-delay: 0ms;
				z-index: 2;
			}
			#color1{
				background:linear-gradient(333deg, rgba(165,45,72,1) 0%, rgba(125,26,78,1) 40%, rgba(63,12,39,1) 100%); 
			}
			#color2{
				background:linear-gradient(225deg, rgba(2,72,66,1) 0%, rgba(0,81,76,1) 30%, rgba(0,108,110,1) 100%); 
			}
			#color3{
				background:linear-gradient(331deg, rgba(8,1,99,1) 0%, rgba(15,12,64,1) 70%, rgba(3,4,38,1) 100%);; 
			}
			canvas { width: 100%; height: 100%; position:relative; z-index: 3; }
			.dg.ac{ z-index:999 !important; }
		</style>
	</head>
	<body>
		<div id="color1" class="color active"></div>
		<div id="color2" class="color"></div>
		<div id="color3" class="color"></div>
		<script id="vertexShader" type="x-shader/x-vertex">
			attribute vec3 color;
			varying vec4 vColor;
			uniform float time;
			uniform float size;
			void main()	{
				vec3 newPosition = position;
				if(time > 0.){
					newPosition.x += sin(newPosition.x + time) * .1;
					newPosition.y += -cos(newPosition.y + time) * .1;
					newPosition.z += -cos(newPosition.z + time) * .1;
				}

				vec4 position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
				gl_Position = position;

				vColor = vec4(color,1.);
				gl_PointSize = size;
			}
		</script>
	
		<script id="fragmentShader" type="x-shader/x-fragment">
			varying vec4 vColor;
			uniform sampler2D texture;
			uniform vec3 fogColor;
			uniform float fogNear;
			uniform float fogFar;
			void main()	{
				vec4 textureColor = texture2D(texture, gl_PointCoord);
				if ( textureColor.w < .8 ) discard;
				gl_FragColor = vColor * textureColor;
				#ifdef USE_LOGDEPTHBUF_EXT
					float depth = gl_FragDepthEXT / gl_FragCoord.w;
				#else
					float depth = gl_FragCoord.z / gl_FragCoord.w;
				#endif
				float fogFactor = smoothstep( fogNear, fogFar, depth );
		  
				gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
			}
		</script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/105/three.min.js"></script>
        <script src="./LoaderSupport.js"></script>
		<script src="./OBJLoader2.js"></script>
		<!-- <script src="http://dev.miaumiau.cat/curl_particles_collision/js/CameraControl.js"></script> -->
		<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/2.1.2/TweenMax.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5/dat.gui.min.js"></script>
		<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/controls/OrbitControls.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/chroma-js/2.0.3/chroma.min.js"></script>
		<script>
			//
			// Add, Remove and Has Class
			//
			var hasClass = function(el, className){
				if(el.classList)
					return el.classList.contains(className)
				else
					return !!el.className.match(new RegExp('(\\s|^)' + className + '(\\s|$)'))
			}

			var  addClass = function(el, className){
				if(el.classList)
					el.classList.add(className)
				else if(!hasClass(el, className)) el.className += " " + className
			}

			var removeClass = function(el, className){
				var isNodelist = (typeof el.length != 'undefined' && typeof el.item != 'undefined')
				if(isNodelist){
					var els = el;

					for(var i=0; els[i]; i++){
						if(els[i].classList)
							els[i].classList.remove(className)
						else if(hasClass(els[i], className)){
							var reg = new RegExp('(\\s|^)' + className + '(\\s|$)')
							els[i].className=els[i].className.replace(reg, ' ')
						}
					}
				}
				else{
					if(el.classList)
						el.classList.remove(className)
					else if(hasClass(el, className)){
						var reg = new RegExp('(\\s|^)' + className + '(\\s|$)')
						el.className=el.className.replace(reg, ' ')
					}
				}
			}


			var maxPoints = 32000;
			var started = false;

            var scene = new THREE.Scene();
				scene.fog = new THREE.Fog( 0x000000, 20, 60 );
			var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
			camera.position.z = 27;
			// var controls = new THREE.OrbitControls( camera );

            var renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setClearColor( 0x000000, 0 );
			document.body.appendChild( renderer.domElement );

		
			window.addEventListener( 'resize', onWindowResize, false );
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}


			var options = {
				wave: false,
				point:{
					size:4,
					depth:.8
				},
				camera:{
					z:camera.position.z
				},
				fogNear:scene.fog.near,
				fogFar:scene.fog.far,
				ToModel1: function(){
					morphTo(modelPoint[0]);
					removeClass(document.querySelector('.color.active'),'active');
					addClass(document.querySelector('#color1'), 'active');
					scene.fog.color = new THREE.Color(0x3f0c27);
				},
				ToModel2: function(){
					morphTo(modelPoint[1]);
					removeClass(document.querySelector('.color.active'),'active');
					addClass(document.querySelector('#color2'), 'active');
					scene.fog.color = new THREE.Color(0x024842);
				},
				ToModel3: function(){
					morphTo(modelPoint[2]);
					removeClass(document.querySelector('.color.active'),'active');
					addClass(document.querySelector('#color3'), 'active');
					scene.fog.color = new THREE.Color(0x3e4ea0);
				}
			}
			var gui = new dat.GUI({width: 300});
			gui.add(options.point, 'size').min(1).max(100).name('Size of point');
			gui.add(options.camera, 'z').min(0).max(50).name('Move Camera');
			var _f = gui.addFolder('Fog');
			_f.add(options, 'fogNear').min(.1).max(20).name('Near');
			_f.add(options, 'fogFar').min(20).max(60).name('Far');
			_f.open();
			gui.add(options, 'ToModel1').name('Morph to Model 1');
			gui.add(options, 'ToModel2').name('Morph to Model 2');
			gui.add(options, 'ToModel3').name('Morph to Model 3');
			gui.add(options, 'wave').name('wave');

			
			var createTexture = function(text,size){
				var actualSize = 1024;
				var canvas = document.createElement('canvas');
				var ctx = canvas.getContext('2d');
				ctx.canvas.width = actualSize;
				ctx.canvas.height = actualSize;
				ctx.beginPath();
				ctx.arc(actualSize/2, actualSize/2, actualSize/2, 0, 2 * Math.PI);
				ctx.fillStyle = 'white';
				ctx.fill();
				if(text){
					ctx.fillStyle = 'red';
					ctx.fill();
					ctx.font = (actualSize/(size*2))+"px Arial";
					ctx.fillStyle = 'white';
					ctx.fontWeight = "bold";
					ctx.textAlign = "center";
					ctx.fillText(text, actualSize/2 , actualSize/2 + ((actualSize/(size*2))/3) );
				}
				return canvas;
			}
			var pointsGeometry = new THREE.BufferGeometry();
			var pointsMaterial;
			var finallyPoint;
			// var deerPoint,model1Point,earthPoint;
			var modelPoint = [];
			var color = 0xff00ff;
			var uniforms = {
				time: { value: 0 },
				size: { value: options.point.size },
				texture:{
					type: "t",
					value: new THREE.CanvasTexture(createTexture())//new THREE.TextureLoader().load('https://klevron.github.io/codepen/misc/star.png')
				},
				fogColor:    { type: "c", value: scene.fog.color },
				fogNear:     { type: "f", value: scene.fog.near },
				fogFar:      { type: "f", value: scene.fog.far }
			};
			

			var pointsMaterial = new THREE.ShaderMaterial({
				uniforms: uniforms,
				vertexShader: document.getElementById('vertexShader').textContent,
				fragmentShader: document.getElementById('fragmentShader').textContent,
				blending: THREE.AdditiveBlending,
				// depthTest: true,
    			depthWrite: false,
				// transparent: true,
				fog:true
			});


            var loadOBJ = function(){
				var manager = new THREE.LoadingManager();
				manager.onLoad = function(){
					console.log( 'Loading complete!');

					// init
					var cscale = chroma.scale([0x00b9e0, 0xff880a, 0x5f1b90, 0x7ec08d]);
					var positions = new Float32Array( maxPoints * 3 );
					colors = new Float32Array( maxPoints * 3 );
					for(var i=0; i<maxPoints; i++){
						color = new THREE.Color(0xffffff);//cscale(THREE.Math.randFloat(0, 1)).hex());
						color.toArray(colors, i*3);
					}
					pointsGeometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
					pointsGeometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ));

					finallyPoint = new THREE.Points( pointsGeometry, pointsMaterial );
					finallyPoint.scale.set(2,2,2);
					scene.add(finallyPoint);

					morphTo(modelPoint[0]);
				};

				var objFiles = [
					['./model1.obj', -5],
					['./model2.obj', -6.5],
					['./model3.obj', -6.5]
				];


				var loadObj = function(idx, file, reposition){
					var loader = new THREE.OBJLoader2(manager);
					loader.load(file, function(obj){
						var geometry = obj.detail.loaderRootNode;
						geometry.traverse(function(child){
							if ( child instanceof THREE.Mesh ){

								// change to geometry
								var geo = new THREE.Geometry().fromBufferGeometry( child.geometry );
								geo.mergeVertices();
								modelPoint[idx] = (new THREE.Points( geo , pointsMaterial ));
								for(var i=0; modelPoint[idx].geometry.vertices[i]; i++){
									modelPoint[idx].geometry.vertices[i].y += reposition;
								}
								console.log('model1: ',modelPoint[idx].geometry.vertices.length, modelPoint[idx]);
							}
						});
					}, null, null, null, false );
				}

				for(var i=0; objFiles[i]; i++){
					loadObj(i, objFiles[i][0], objFiles[i][1]);
				}

				// var loader = new THREE.OBJLoader2(manager);
				// loader.load( './model1.obj', function ( obj ) {
				// 	var geometry = obj.detail.loaderRootNode;
				// 	geometry.traverse( function( child ) {
				// 		if ( child instanceof THREE.Mesh ) {

				// 			// change to geometry
				// 			var geo = new THREE.Geometry().fromBufferGeometry( child.geometry );
				// 			geo.mergeVertices();
				// 			model1Point = new THREE.Points( geo , pointsMaterial );
				// 			for(var i=0; model1Point.geometry.vertices[i]; i++){
				// 				model1Point.geometry.vertices[i].y += -5;
				// 			}
				// 			console.log('model1: ',model1Point.geometry.vertices.length,model1Point);
				// 		}
				// 	});
				// }, null, null, null, false );

				// loader = new THREE.OBJLoader2(manager);
                // loader.load( './model2.obj', function ( obj ) {
				// 	var geometry = obj.detail.loaderRootNode;
				// 	geometry.traverse( function( child ) {
				// 		if ( child instanceof THREE.Mesh ) {
				// 			// change to geometry
				// 			var geo = new THREE.Geometry().fromBufferGeometry( child.geometry );
				// 			geo.mergeVertices();
				// 			deerPoint = new THREE.Points( geo, pointsMaterial );
				// 			for(var i=0; deerPoint.geometry.vertices[i]; i++){
				// 				deerPoint.geometry.vertices[i].y += -6.5;
				// 			}
				// 			console.log('model2: ',deerPoint.geometry.vertices.length);
				// 		}
				// 	});
				// }, null, null, null, false );
				

				var geo = new THREE.IcosahedronGeometry(3,4);
				earthPoint = new THREE.Points( geo , pointsMaterial );
            }
			loadOBJ();

			var targetMesh;
			var target = [];
			var morphTo = function(mesh){
				var pos = pointsGeometry.attributes.position.array;
				targetMesh = mesh;
				for(var i=0; i<maxPoints; i++){
					if(targetMesh.geometry.vertices[i]){
						target[i] = {
							x:mesh.geometry.vertices[i].x,
							y:mesh.geometry.vertices[i].y,
							z:mesh.geometry.vertices[i].z
						};
					}
					else{
						target[i] = {
							x:THREE.Math.randFloat(-20,20),
							y:THREE.Math.randFloat(-20,20),
							z:THREE.Math.randFloat(-20,20)
						};
					}
				}
			}



			var start = Date.now();
			// var done = false;
            var animate = function () {
				requestAnimationFrame( animate );

				var timer = (Date.now() - start) / 10000;

				if(targetMesh){
					var pos = pointsGeometry.attributes.position.array;
					for(var i=0; i<maxPoints; i++){
						if(targetMesh.geometry.vertices[i]){
							pos[i*3+0] += (target[i].x - pos[i*3+0]) * .1;
							pos[i*3+1] += (target[i].y - pos[i*3+1]) * .1;
							pos[i*3+2] += (target[i].z - pos[i*3+2]) * .1;
						}
						else{
							pos[i*3+0] += (target[i].x - pos[i*3+0]) * .01;
							pos[i*3+1] += (target[i].y - pos[i*3+1]) * .01;
							pos[i*3+2] += (target[i].z - pos[i*3+2]) * .01;

							pos[i*3+0] += Math.sin(target[i].x + timer) * .05;
							pos[i*3+1] += -Math.cos(target[i].y + timer) * .05;
							pos[i*3+2] += -Math.cos(target[i].z + timer) * .05;
						}
					}
					if(!started) started = true;
				}
				// 
				if(finallyPoint){
					finallyPoint.rotation.y = -timer;
					
					if(options.wave){
						finallyPoint.material.uniforms.time.value+=.05;
					}
					else
						finallyPoint.material.uniforms.time.value = 0;

					finallyPoint.material.uniforms.size.value = options.point.size;
					scene.fog.near = options.fogNear;
					scene.fog.far = options.fogFar;
				}


				camera.position.z = options.camera.z;

				if(pointsGeometry.attributes.position) pointsGeometry.attributes.position.needsUpdate = true;
				// if(pointsGeometry.attributes.alpha) pointsGeometry.attributes.alpha.needsUpdate = true;
				if(pointsGeometry.attributes.color) pointsGeometry.attributes.color.needsUpdate = true;

				camera.lookAt(new THREE.Vector3(0,0,0));
                // controls.update();
				renderer.render( scene, camera );
            };
            animate();

			//
			// Random
			//
			var random = function( min , max , isRound ){
				var ran = (Math.random() * (max - min)) + min;
				if(isRound)
					return Math.round(ran);
				else
					return ran;
			}

		</script>
	</body>
</html>