<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>particles</title>
		<style>
			html,body{ overflow: hidden; }
			body { padding:0; margin: 0; }
			canvas { width: 100%; height: 100%; }
		</style>
	</head>
	<body>
		<script id="vertexShader" type="x-shader/x-vertex">
			attribute vec3 color;
			varying vec4 vColor;
			uniform float time;
			uniform float size;
			void main()	{
				vec3 newPosition = position;
				newPosition.x += sin(newPosition.x + time) * .1;
				newPosition.y += -cos(newPosition.y + time) * .1;
				newPosition.z += -cos(newPosition.z + time) * .1;

				vec4 position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
				gl_Position = position;

				vColor = vec4(color,1.);
				gl_PointSize = size;
			}
		</script>
	
		<script id="fragmentShader" type="x-shader/x-fragment">
			varying vec4 vColor;
			uniform sampler2D texture;
			uniform vec3 fogColor;
			uniform float fogNear;
			uniform float fogFar;
			void main()	{
				vec4 textureColor = texture2D(texture, gl_PointCoord);
				if ( textureColor.w < .8 ) discard;
				gl_FragColor = vColor * textureColor;
				#ifdef USE_LOGDEPTHBUF_EXT
					float depth = gl_FragDepthEXT / gl_FragCoord.w;
				#else
					float depth = gl_FragCoord.z / gl_FragCoord.w;
				#endif
				float fogFactor = smoothstep( fogNear, fogFar, depth );
		  
				gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
			}
		</script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/105/three.min.js"></script>
        <script src="./LoaderSupport.js"></script>
		<script src="./OBJLoader2.js"></script>
		<!-- <script src="http://dev.miaumiau.cat/curl_particles_collision/js/CameraControl.js"></script> -->
		<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/2.1.2/TweenMax.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5/dat.gui.min.js"></script>
		<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/controls/OrbitControls.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/chroma-js/2.0.3/chroma.min.js"></script>
		<script>
			var maxPoints = 3000;
			var started = false;

            var scene = new THREE.Scene();
				scene.fog = new THREE.Fog( 0x000000, 20, 30 );
			var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
			camera.position.z = 22;
			// var controls = new THREE.OrbitControls( camera );

            var renderer = new THREE.WebGLRenderer( { antialias: true } );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setClearColor( 0x000000, 1 );
			document.body.appendChild( renderer.domElement );

			// light
            var ambientLight = new THREE.AmbientLight( 0x222222 );
            scene.add( ambientLight );
            var lights = [];
			lights[ 0 ] = new THREE.PointLight( 0xff0000, 1, 0 );
			lights[ 1 ] = new THREE.PointLight( 0x00ff00, 1, 0 );
			lights[ 2 ] = new THREE.PointLight( 0x0000ff, 1, 0 );

			lights[ 0 ].position.set( -22, 0, 22 );
			lights[ 1 ].position.set( 22, 0, 22 );
			lights[ 2 ].position.set( 0, 0 , 22 );

			scene.add( lights[ 0 ] );
			scene.add( lights[ 1 ] );
			scene.add( lights[ 2 ] );

			var options = {
				wave: false,
				point:{
					size:10,
					depth:.8
				},
				camera:{
					z:camera.position.z
				},
				fogNear:scene.fog.near,
				fogFar:scene.fog.far,
				ToRabbit: function(){
					morphTo(rabbitPoint);
				},
				ToPear: function(){
					morphTo(deerPoint);
				},
				ToEarth: function(){
					morphTo(earthPoint);
				}
			}
			var gui = new dat.GUI({width: 300});
			gui.add(options.point, 'size').min(1).max(100).name('Size of point');
			gui.add(options.camera, 'z').min(0).max(50).name('Move Camera');
			var _f = gui.addFolder('Fog');
			_f.add(options, 'fogNear').min(.1).max(20).name('Near');
			_f.add(options, 'fogFar').min(20).max(60).name('Far');
			_f.open();
			gui.add(options, 'ToRabbit').name('Morph to üêá');
			gui.add(options, 'ToPear').name('Morph to üçê');
			gui.add(options, 'ToEarth').name('Morph to Earth');
			gui.add(options, 'wave').name('wave');

			
			var createTexture = function(text,size){
				var actualSize = 1024;
				var canvas = document.createElement('canvas');
				var ctx = canvas.getContext('2d');
				ctx.canvas.width = actualSize;
				ctx.canvas.height = actualSize;
				ctx.beginPath();
				ctx.arc(actualSize/2, actualSize/2, actualSize/2, 0, 2 * Math.PI);
				ctx.fillStyle = 'white';
				ctx.fill();
				if(text){
					ctx.fillStyle = 'red';
					ctx.fill();
					ctx.font = (actualSize/(size*2))+"px Arial";
					ctx.fillStyle = 'white';
					ctx.fontWeight = "bold";
					ctx.textAlign = "center";
					ctx.fillText(text, actualSize/2 , actualSize/2 + ((actualSize/(size*2))/3) );
				}
				return canvas;
			}
			var pointsGeometry = new THREE.BufferGeometry();
			var pointsMaterial;
			var finallyPoint;
			var deerPoint,rabbitPoint,earthPoint;
			var color = 0xff00ff;
			var uniforms = {
				time: { value: 0 },
				size: { value: options.point.size },
				texture:{
					type: "t",
					value: new THREE.CanvasTexture(createTexture())//new THREE.TextureLoader().load('https://klevron.github.io/codepen/misc/star.png')
				},
				fogColor:    { type: "c", value: scene.fog.color },
				fogNear:     { type: "f", value: scene.fog.near },
				fogFar:      { type: "f", value: scene.fog.far }
			};
			

			var pointsMaterial = new THREE.ShaderMaterial({
				uniforms: uniforms,
				vertexShader: document.getElementById('vertexShader').textContent,
				fragmentShader: document.getElementById('fragmentShader').textContent,
				blending: THREE.AdditiveBlending,
				// depthTest: true,
    			depthWrite: false,
				// transparent: true,
				fog:true
			});


            var loadOBJ = function(){
				var manager = new THREE.LoadingManager();
				manager.onLoad = function(){
					console.log( 'Loading complete!');

					// init
					var cscale = chroma.scale([0x00b9e0, 0xff880a, 0x5f1b90, 0x7ec08d]);
					var positions = new Float32Array( maxPoints * 3 );
					colors = new Float32Array( maxPoints * 3 );
					for(var i=0; i<maxPoints; i++){
						color = new THREE.Color(cscale(THREE.Math.randFloat(0, 1)).hex());
						color.toArray(colors, i*3);
					}
					pointsGeometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
					pointsGeometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ));

					finallyPoint = new THREE.Points( pointsGeometry, pointsMaterial );
					finallyPoint.scale.set(3,3,3);
					scene.add(finallyPoint);

					morphTo(rabbitPoint);
				};

				var loader = new THREE.OBJLoader2(manager);
				loader.load( './model1.obj', function ( obj ) {
					var geometry = obj.detail.loaderRootNode;
					geometry.traverse( function( child ) {
						if ( child instanceof THREE.Mesh ) {

							// change to geometry
							var geo = new THREE.Geometry().fromBufferGeometry( child.geometry );
							geo.mergeVertices();
							rabbitPoint = new THREE.Points( geo , pointsMaterial );
							for(var i=0; rabbitPoint.geometry.vertices[i]; i++){
								rabbitPoint.geometry.vertices[i].y -= 3;
							}
							console.log('rabbit: ',rabbitPoint.geometry.vertices.length,rabbitPoint);
						}
					});
				}, null, null, null, false );

				loader = new THREE.OBJLoader2(manager);
                loader.load( './model2.obj', function ( obj ) {
					var geometry = obj.detail.loaderRootNode;
					geometry.traverse( function( child ) {
						if ( child instanceof THREE.Mesh ) {
							// change to geometry
							var geo = new THREE.Geometry().fromBufferGeometry( child.geometry );
							geo.mergeVertices();
							deerPoint = new THREE.Points( geo, pointsMaterial );
							for(var i=0; deerPoint.geometry.vertices[i]; i++){
								deerPoint.geometry.vertices[i].y -= 1;
							}
							console.log('pear: ',deerPoint.geometry.vertices.length);
						}
					});
				}, null, null, null, false );
				

				var geo = new THREE.IcosahedronGeometry(3,4);
				earthPoint = new THREE.Points( geo , pointsMaterial );
            }
			loadOBJ();

			var targetMesh;
			var target = [];
			var morphTo = function(mesh){
				var pos = pointsGeometry.attributes.position.array;
				targetMesh = mesh;
				for(var i=0; i<maxPoints; i++){
					if(targetMesh.geometry.vertices[i]){
						target[i] = {
							x:mesh.geometry.vertices[i].x,
							y:mesh.geometry.vertices[i].y,
							z:mesh.geometry.vertices[i].z
						};
					}
					else{
						target[i] = {
							x:THREE.Math.randFloat(-10,10),
							y:THREE.Math.randFloat(-10,10),
							z:THREE.Math.randFloat(-10,10)
						};
					}
				}
			}



			var start = Date.now();
			// var done = false;
            var animate = function () {
				requestAnimationFrame( animate );

				var timer = (Date.now() - start) / 10000;

				if(targetMesh){
					var pos = pointsGeometry.attributes.position.array;
					for(var i=0; i<maxPoints; i++){
						if(targetMesh.geometry.vertices[i]){
							pos[i*3+0] += (target[i].x - pos[i*3+0]) * .1;
							pos[i*3+1] += (target[i].y - pos[i*3+1]) * .1;
							pos[i*3+2] += (target[i].z - pos[i*3+2]) * .1;
						}
						else{
							pos[i*3+0] += (target[i].x - pos[i*3+0]) * .01;
							pos[i*3+1] += (target[i].y - pos[i*3+1]) * .01;
							pos[i*3+2] += (target[i].z - pos[i*3+2]) * .01;
						}
					}
					if(!started) started = true;
				}
				// 
				if(finallyPoint){
					finallyPoint.rotation.y = -timer;
					if(options.wave){
						// TweenMax.killAll();
						finallyPoint.material.uniforms.time.value+=.05;
					}
					else
						TweenMax.set(finallyPoint.material.uniforms.time,{value:0});

					finallyPoint.material.uniforms.size.value = options.point.size;
					scene.fog.near = options.fogNear;
					scene.fog.far = options.fogFar;
				}


				camera.position.z = options.camera.z;

				if(pointsGeometry.attributes.position) pointsGeometry.attributes.position.needsUpdate = true;
				if(pointsGeometry.attributes.alpha) pointsGeometry.attributes.alpha.needsUpdate = true;
				if(pointsGeometry.attributes.color) pointsGeometry.attributes.color.needsUpdate = true;

				camera.lookAt(new THREE.Vector3(0,0,0));
                // controls.update();
				renderer.render( scene, camera );
            };
            animate();

			//
			// Random
			//
			var random = function( min , max , isRound ){
				var ran = (Math.random() * (max - min)) + min;
				if(isRound)
					return Math.round(ran);
				else
					return ran;
			}

		</script>
	</body>
</html>